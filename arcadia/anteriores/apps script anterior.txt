/**
 * @OnlyCurrentDoc
 * Backend para la app de caja.
 * - doPost: guarda los registros que envía el front.
 * - doGet?action=report&from=YYYY-MM-DD&to=YYYY-MM-DD: devuelve filas SOLO de TOTALES.
 * - doGet?action=details&from=YYYY-MM-DD&to=YYYY-MM-DD: devuelve filas de DETALLE (excluye totales).
 * - doGet?action=export&from=YYYY-MM-DD&to=YYYY-MM-DD: genera y devuelve URL para descargar en Excel (.xlsx).
 */

/** ====== CONFIGURACIÓN ====== */
const SHEET_NAME = 'Hoja 1'; // <-- usa el nombre exacto de tu pestaña
const REQUIRED_HEADERS = ['fecha','puntoVenta','tipo','tercero','detalle','valor'];

// Textos de "tipo" que cuentan para RESÚMENES/TOTALES (deben coincidir EXACTO a los de la hoja)
const TOTALES_VALIDOS = new Set([
  'Total dinero a recibir por tesoreria',
  'Total gastos en efectivo',
  'Total ventas',
  'Total ventas a credito',
  'Total ventas en efectivo',
  'Total ventas por medios electronicos'
]);

// (Opcional) token simple para POST/GET (?key=...); deja vacío para desactivar
const API_KEY = ''; // p.ej. 'secreto-super-simple'

/** ====== CORS Y UTILIDADES HTTP ====== */
function doOptions(e) { // para preflight de CORS
  return _withCors(ContentService.createTextOutput(''), e);
}
function _withCors(output, e) {
  // ContentService no permite setear todos los headers CORS; devolvemos JSON estándar.
  return output.setMimeType(ContentService.MimeType.JSON);
}
function _checkApiKey(e) {
  if (!API_KEY) return; // sin seguridad simple
  const viaQuery = e?.parameter?.key;
  if (viaQuery !== API_KEY) throw new Error('No autorizado (API key incorrecta o ausente).');
}

/** ====== GUARDADO (POST) ====== */
function doPost(e) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  try {
    _checkApiKey(e);

    const sheet = SpreadsheetApp.getActive().getSheetByName(SHEET_NAME);
    if (!sheet) throw new Error('No existe la hoja "'+SHEET_NAME+'"');

    if (!e || !e.postData || !e.postData.contents) throw new Error('POST vacío');
    let payload;
    try {
      payload = JSON.parse(e.postData.contents);
    } catch {
      throw new Error('JSON inválido en el cuerpo de la solicitud');
    }

    const records = Array.isArray(payload) ? payload : [payload];
    if (!records.length) throw new Error('No hay registros para guardar');

    // Verifica encabezados presentes en la hoja
    const data = sheet.getDataRange().getValues();
    const headerRowIndex = encontrarFilaEncabezados(data, REQUIRED_HEADERS);
    if (headerRowIndex === -1) {
      throw new Error('No se encontraron los encabezados: '+REQUIRED_HEADERS.join(', '));
    }

    // Construye filas para guardar respetando el orden de columnas de la hoja
    const header = data[headerRowIndex].map(v => String(v).trim());
    const colIdx = Object.fromEntries(REQUIRED_HEADERS.map(h => [h, header.indexOf(h)]));
    REQUIRED_HEADERS.forEach(h => { if (colIdx[h] === -1) throw new Error('Falta columna en hoja: '+h); });

    // Prepara matriz con tantas columnas como la hoja tenga (mínimo hasta la última requerida)
    const lastCol = Math.max(...Object.values(colIdx)) + 1;

    const rows = [];
    for (let i = 0; i < records.length; i++) {
      const rec = records[i] || {};
      for (const h of REQUIRED_HEADERS) {
        if (!(h in rec)) throw new Error(`Falta el campo requerido "${h}" en el registro ${i+1}`);
      }

      let v = rec.valor;
      if (typeof v === 'string') {
        v = v.replace(/\s/g, '').replace(/\./g, '').replace(',', '.');
        v = parseFloat(v);
      }
      if (typeof v !== 'number' || !isFinite(v)) v = 0;

      const row = new Array(lastCol).fill('');
      row[colIdx.fecha]      = rec.fecha;
      row[colIdx.puntoVenta] = rec.puntoVenta;
      row[colIdx.tipo]       = rec.tipo;
      row[colIdx.tercero]    = rec.tercero;
      row[colIdx.detalle]    = rec.detalle;
      row[colIdx.valor]      = Number(v) || 0;

      rows.push(row);
    }

    // Inserta a partir de la primera fila libre DESPUÉS de la fila de encabezados
    const startRow = Math.max(sheet.getLastRow() + 1, headerRowIndex + 2);

    // ✅ Escribe datos
    const writeRange = sheet.getRange(startRow, 1, rows.length, rows[0].length);
    writeRange.setValues(rows);

    // ✅ 1) Ningún valor debe quedar con "$": fuerza formato numérico (sin moneda) en la columna "valor"
    sheet.getRange(startRow, colIdx.valor + 1, rows.length, 1).setNumberFormat('#,##0');

    // ✅ 2) Filas de totales en negrita (toda la fila) para diferenciarlas de los detalles
    for (let i = 0; i < records.length; i++) {
      const tipo = String((records[i] || {}).tipo || '').trim();
      if (TOTALES_VALIDOS.has(tipo)) {
        sheet.getRange(startRow + i, 1, 1, rows[0].length).setFontWeight('bold');
      }
    }

    return _withCors(_json({ result: 'success', rowsAdded: rows.length }), e);

  } catch (error) {
    Logger.log(error);
    return _withCors(_json({ result: 'error', error: String(error.message || error) }), e);

  } finally {
    lock.releaseLock();
  }
}

/** ====== REPORTE / DETALLES / EXPORT (GET) ======
 * action=report  &from=YYYY-MM-DD&to=YYYY-MM-DD  -> JSON de filas SOLO TOTALES.
 * action=details &from=YYYY-MM-DD&to=YYYY-MM-DD  -> JSON de filas de DETALLE (excluye totales).
 * action=export  &from=YYYY-MM-DD&to=YYYY-MM-DD  -> {result:'ok', downloadUrl:'...xlsx'}.
 */
function doGet(e) {
  try {
    _checkApiKey(e);

    const p = e?.parameter || {};
    if (!p.action) {
      return _withCors(_json({ result: 'error', error: 'Falta parámetro action' }), e);
    }
    if (!p.from || !p.to) {
      return _withCors(_json({ result: 'error', error: 'Faltan parámetros from/to (YYYY-MM-DD)' }), e);
    }

    const tz = Session.getScriptTimeZone();
    const dFrom = _dayStart(p.from, tz);
    const dTo   = _dayEnd(p.to, tz);
    if (isNaN(dFrom) || isNaN(dTo)) {
      return _withCors(_json({ result: 'error', error: 'Formato de fecha inválido. Usa YYYY-MM-DD' }), e);
    }
    if (dFrom > dTo) {
      return _withCors(_json({ result: 'error', error: '"from" no puede ser mayor que "to"' }), e);
    }

    if (p.action === 'report') {
      const rows = leerTotalesPorRango(p.from, p.to);
      return _withCors(_json(rows), e);
    }

    if (p.action === 'details') {
      const rows = leerDetallesPorRango(p.from, p.to);
      return _withCors(_json(rows), e);
    }

    if (p.action === 'export') {
      const rows = leerTotalesPorRango(p.from, p.to);
      const info = _crearArchivoExcelDesdeFilas(rows, `Reporte_${p.from}_a_${p.to}`);
      return _withCors(_json({ result: 'ok', ...info }), e);
    }

    return _withCors(_json({ result: 'error', error: 'Acción no soportada. Usa action=report, details o export' }), e);

  } catch (err) {
    return _withCors(_json({ result: 'error', error: String(err) }), e);
  }
}

/** ====== LECTURAS ====== */

/** Totales por rango: devuelve SOLO filas cuyo "tipo" ∈ TOTALES_VALIDOS */
function leerTotalesPorRango(fromISO, toISO) {
  const { data, headerRowIndex, idx } = _leerHojaYCabecera_();

  const tz = Session.getScriptTimeZone();
  const dFrom = _dayStart(fromISO, tz);
  const dTo   = _dayEnd(toISO, tz);

  const out = [];
  for (let r = headerRowIndex + 1; r < data.length; r++) {
    const row = data[r];
    if (!row || row.length === 0 || row.every(v => v === '' || v === null)) continue;

    const f = _coerceFecha(row[idx.fecha]);
    if (!f) continue;
    if (f < dFrom || f > dTo) continue;

    const tipo = String(row[idx.tipo] || '').trim();
    if (!TOTALES_VALIDOS.has(tipo)) continue;

    const punto = String(row[idx.puntoVenta] || '').trim();
    const valorNum = _toNumber(row[idx.valor]);

    out.push({
      fecha: Utilities.formatDate(f, tz, 'yyyy-MM-dd'),
      puntoVenta: punto,
      tipo: tipo,
      valor: valorNum
    });
  }

  return out;
}

/** Detalles por rango: devuelve filas cuyo "tipo" NO esté en TOTALES_VALIDOS */
function leerDetallesPorRango(fromISO, toISO) {
  const { data, headerRowIndex, idx } = _leerHojaYCabecera_();

  const tz = Session.getScriptTimeZone();
  const dFrom = _dayStart(fromISO, tz);
  const dTo   = _dayEnd(toISO, tz);

  const out = [];
  for (let r = headerRowIndex + 1; r < data.length; r++) {
    const row = data[r];
    if (!row || row.length === 0 || row.every(v => v === '' || v === null)) continue;

    const f = _coerceFecha(row[idx.fecha]);
    if (!f) continue;
    if (f < dFrom || f > dTo) continue;

    const tipo = String(row[idx.tipo] || '').trim();
    if (TOTALES_VALIDOS.has(tipo)) continue; // excluye totales

    const punto    = String(row[idx.puntoVenta] || '').trim();
    const tercero  = String(row[idx.tercero] || '').trim();
    const detalle  = String(row[idx.detalle] || '').trim();
    const valorNum = _toNumber(row[idx.valor]);

    out.push({
      fecha: Utilities.formatDate(f, tz, 'yyyy-MM-dd'),
      puntoVenta: punto,
      tipo: tipo,
      tercero: tercero,
      detalle: detalle,
      valor: valorNum
    });
  }

  return out;
}

/** Lee hoja y cabecera; devuelve data completa, índice de fila de encabezados e índices por columna requerida */
function _leerHojaYCabecera_(){
  const sh = SpreadsheetApp.getActive().getSheetByName(SHEET_NAME);
  if (!sh) throw new Error('No existe la hoja "'+SHEET_NAME+'"');

  const data = sh.getDataRange().getValues();
  const headerRowIndex = encontrarFilaEncabezados(data, REQUIRED_HEADERS);
  if (headerRowIndex === -1) {
    throw new Error('No se encontraron los encabezados requeridos: '+REQUIRED_HEADERS.join(', '));
  }
  const header = data[headerRowIndex].map(v => String(v).trim());
  const idx = Object.fromEntries(REQUIRED_HEADERS.map(h => [h, header.indexOf(h)]));
  REQUIRED_HEADERS.forEach(h => { if (idx[h] === -1) throw new Error('Falta columna: '+h); });

  return { data, headerRowIndex, idx };
}

/** ====== EXPORTACIÓN XLSX (opcional, para totales) ====== */
function _crearArchivoExcelDesdeFilas(rows, nombreBase) {
  const headers = ['fecha','puntoVenta','tipo','valor'];
  const ss = SpreadsheetApp.create(nombreBase || 'Reporte');
  const sh = ss.getActiveSheet();
  sh.setName('Reporte');

  const matrix = [headers, ...rows.map(r => [r.fecha, r.puntoVenta, r.tipo, r.valor])];
  sh.getRange(1, 1, matrix.length, headers.length).setValues(matrix);
  sh.getRange(1, 1, 1, headers.length).setFontWeight('bold');
  sh.autoResizeColumns(1, headers.length);

  const fileId = ss.getId();
  const downloadUrl = `https://docs.google.com/spreadsheets/d/${fileId}/export?format=xlsx`;
  return { fileId, downloadUrl };
}

/** ====== UTILIDADES ====== */
function encontrarFilaEncabezados(matrix, required) {
  for (let i = 0; i < Math.min(matrix.length, 15); i++) {
    const set = new Set(matrix[i].map(v => String(v).trim()));
    if (required.every(h => set.has(h))) return i;
  }
  return -1;
}

function _json(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function _parseYMD(val) {
  if (!val) return null;
  const s = String(val).trim();
  const m = s.match(/^(\d{4})[-/](\d{2})[-/](\d{2})$/);
  if (!m) return null;
  const d = new Date(`${m[1]}-${m[2]}-${m[3]}T00:00:00`);
  return isNaN(d) ? null : d;
}
function _dayStart(iso, tz) {
  const d = _parseYMD(iso);
  if (!d) return new Date('invalid');
  const s = Utilities.formatDate(d, tz, 'yyyy-MM-dd') + ' 00:00:00';
  return new Date(s);
}
function _dayEnd(iso, tz) {
  const d = _parseYMD(iso);
  if (!d) return new Date('invalid');
  const s = Utilities.formatDate(d, tz, 'yyyy-MM-dd') + ' 23:59:59';
  return new Date(s);
}
function _coerceFecha(raw){
  return raw instanceof Date ? raw : _parseYMD(raw);
}
function _toNumber(v){
  if (typeof v === 'string') {
    v = v.replace(/\s/g, '').replace(/\./g, '').replace(',', '.');
    v = parseFloat(v);
  }
  if (typeof v !== 'number' || !isFinite(v)) v = 0;
  return Number(v) || 0;
}
