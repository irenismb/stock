/**
 * Backend para la app de caja.
 * - doPost: guarda los registros que envía el front en el Spreadsheet "default" (el que contiene el script).
 * - doGet?action=report  &from=YYYY-MM-DD&to=YYYY-MM-DD[&puntoVenta=...] : devuelve filas SOLO de TOTALES.
 * - doGet?action=details &from=YYYY-MM-DD&to=YYYY-MM-DD[&puntoVenta=...] : devuelve filas de DETALLE (excluye totales).
 * - doGet?action=export  &from=YYYY-MM-DD&to=YYYY-MM-DD[&puntoVenta=...] : genera y devuelve URL para descargar en Excel (.xlsx).
 *
 * Formato solicitado:
 * - Todo lo insertado llega SIN negrita.
 * - Filas cuyo tipo sea TOTAL van en negrita SOLO desde la columna B hasta la G.
 * - SOLO "Total dinero a recibir por tesoreria" va con color SOLO desde la columna B hasta la G.
 * - Evitar “arrastres” de formato hacia columnas extra.
 */

/** ====== CONFIGURACIÓN ====== */

// ✅ Hoja: primera pestaña del libro
const SHEET_INDEX = 0;

const REQUIRED_HEADERS = ['fecha','puntoVenta','tipo','tercero','detalle','valor'];

// (Opcional) Si tu hoja ya tiene estas columnas, también las formateamos como número.
const OPTIONAL_NUM_HEADERS = ['devoluciones', 'total'];

// Textos de "tipo" que cuentan para RESÚMENES/TOTALES
const TOTALES_VALIDOS = new Set([
  'Total dinero a recibir por tesoreria',
  'Total gastos en efectivo',
  'Total ventas',
  'Total ventas a credito',

  // ✅ compatibilidad histórica (si existía)
  'Total ventas en efectivo',

  // ✅ nuevo total correcto (para que "Ventas de contado en efectivo" quede como DETALLE)
  'Total ventas de contado en efectivo',

  'Total ventas por medios electronicos'
]);

// ✅ tipo específico de tesorería (color)
const TIPO_TESORERIA = 'Total dinero a recibir por tesoreria';
const COLOR_TESORERIA_RGB = { r: 254, g: 242, b: 205 };

// (Opcional) token simple para POST/GET (?key=...); deja vacío para desactivar
const API_KEY = ''; // p.ej. 'secreto-super-simple'

// ✅ Sets normalizados para comparaciones seguras
const TOTALES_NORM = new Set(Array.from(TOTALES_VALIDOS).map(_normText));
const TIPO_TESORERIA_NORM = _normText(TIPO_TESORERIA);

/** ====== CORS Y UTILIDADES HTTP ====== */
function doOptions(e) {
  return _withCors(ContentService.createTextOutput(''), e);
}
function _withCors(output, e) {
  return output.setMimeType(ContentService.MimeType.JSON);
}
function _checkApiKey(e) {
  if (!API_KEY) return;
  const viaQuery = e?.parameter?.key;
  if (viaQuery !== API_KEY) throw new Error('No autorizado (API key incorrecta o ausente).');
}

/** ====== GUARDADO (POST) ====== */
function doPost(e) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    _checkApiKey(e);

    if (!e || !e.postData || !e.postData.contents) throw new Error('POST vacío');

    let payload;
    try {
      payload = JSON.parse(e.postData.contents);
    } catch {
      throw new Error('JSON inválido en el cuerpo de la solicitud');
    }

    const records = Array.isArray(payload) ? payload : [payload];
    if (!records.length) throw new Error('No hay registros para guardar');

    const { spreadsheet, sheet, headerInfo } = _abrirDestinoYPreparar_();
    const added = _guardarEnHoja_(sheet, headerInfo, records);

    return _withCors(_json({
      result: 'success',
      rowsAdded: added,
      detail: [{
        destino: 'DEFAULT',
        spreadsheetId: spreadsheet.getId(),
        sheetName: sheet.getName(),
        rowsAdded: added
      }]
    }), e);

  } catch (error) {
    Logger.log(error);
    return _withCors(_json({ result: 'error', error: String(error.message || error) }), e);

  } finally {
    lock.releaseLock();
  }
}

/** ====== REPORTE / DETALLES / EXPORT (GET) ====== */
function doGet(e) {
  try {
    _checkApiKey(e);

    const p = e?.parameter || {};
    if (!p.action) return _withCors(_json({ result: 'error', error: 'Falta parámetro action' }), e);
    if (!p.from || !p.to) return _withCors(_json({ result: 'error', error: 'Faltan parámetros from/to (YYYY-MM-DD)' }), e);

    const tz = Session.getScriptTimeZone();
    const dFrom = _dayStart(p.from, tz);
    const dTo   = _dayEnd(p.to, tz);
    if (isNaN(dFrom) || isNaN(dTo)) return _withCors(_json({ result: 'error', error: 'Formato de fecha inválido. Usa YYYY-MM-DD' }), e);
    if (dFrom > dTo) return _withCors(_json({ result: 'error', error: '"from" no puede ser mayor que "to"' }), e);

    const pvFilter = String(p.puntoVenta || '').trim(); // opcional
    const pvFilterNorm = pvFilter ? _normText(pvFilter) : '';

    if (p.action === 'report') {
      const rows = leerTotalesPorRango(p.from, p.to, pvFilterNorm);
      return _withCors(_json(rows), e);
    }

    if (p.action === 'details') {
      const rows = leerDetallesPorRango(p.from, p.to, pvFilterNorm);
      return _withCors(_json(rows), e);
    }

    if (p.action === 'export') {
      const rows = leerTotalesPorRango(p.from, p.to, pvFilterNorm);
      const info = _crearArchivoExcelDesdeFilas(rows, `Reporte_${p.from}_a_${p.to}`);
      return _withCors(_json({ result: 'ok', ...info }), e);
    }

    return _withCors(_json({ result: 'error', error: 'Acción no soportada. Usa action=report, details o export' }), e);

  } catch (err) {
    return _withCors(_json({ result: 'error', error: String(err) }), e);
  }
}

/** ====== LECTURAS ====== */
function leerTotalesPorRango(fromISO, toISO, pvFilterNorm) {
  const tz = Session.getScriptTimeZone();
  const dFrom = _dayStart(fromISO, tz);
  const dTo   = _dayEnd(toISO, tz);

  const { data, headerRowIndex, idx } = _leerHojaYCabecera_();
  const out = [];

  for (let r = headerRowIndex + 1; r < data.length; r++) {
    const row = data[r];
    if (!row || row.length === 0 || row.every(v => v === '' || v === null)) continue;

    const f = _coerceFecha(row[idx.fecha]);
    if (!f) continue;
    if (f < dFrom || f > dTo) continue;

    const punto = String(row[idx.puntoVenta] || '').trim();
    if (pvFilterNorm && _normText(punto) !== pvFilterNorm) continue;

    const tipo = String(row[idx.tipo] || '').trim();
    if (!TOTALES_NORM.has(_normText(tipo))) continue;

    const valorNum = _toNumber(row[idx.valor]);

    out.push({
      fecha: Utilities.formatDate(f, tz, 'yyyy-MM-dd'),
      puntoVenta: punto,
      tipo: tipo,
      valor: valorNum
    });
  }

  out.sort((a,b) =>
    (a.fecha||'').localeCompare(b.fecha||'') ||
    (a.puntoVenta||'').localeCompare(b.puntoVenta||'') ||
    (a.tipo||'').localeCompare(b.tipo||'')
  );

  return out;
}

function leerDetallesPorRango(fromISO, toISO, pvFilterNorm) {
  const tz = Session.getScriptTimeZone();
  const dFrom = _dayStart(fromISO, tz);
  const dTo   = _dayEnd(toISO, tz);

  const { data, headerRowIndex, idx } = _leerHojaYCabecera_();
  const out = [];

  for (let r = headerRowIndex + 1; r < data.length; r++) {
    const row = data[r];
    if (!row || row.length === 0 || row.every(v => v === '' || v === null)) continue;

    const f = _coerceFecha(row[idx.fecha]);
    if (!f) continue;
    if (f < dFrom || f > dTo) continue;

    const punto = String(row[idx.puntoVenta] || '').trim();
    if (pvFilterNorm && _normText(punto) !== pvFilterNorm) continue;

    const tipo = String(row[idx.tipo] || '').trim();
    if (TOTALES_NORM.has(_normText(tipo))) continue;

    const tercero  = String(row[idx.tercero] || '').trim();
    const detalle  = String(row[idx.detalle] || '').trim();
    const valorNum = _toNumber(row[idx.valor]);

    out.push({
      fecha: Utilities.formatDate(f, tz, 'yyyy-MM-dd'),
      puntoVenta: punto,
      tipo: tipo,
      tercero: tercero,
      detalle: detalle,
      valor: valorNum
    });
  }

  out.sort((a,b) =>
    (a.fecha||'').localeCompare(b.fecha||'') ||
    (a.puntoVenta||'').localeCompare(b.puntoVenta||'') ||
    (a.tipo||'').localeCompare(b.tipo||'')
  );

  return out;
}

/** ====== EXPORTACIÓN XLSX (opcional, para totales) ====== */
function _crearArchivoExcelDesdeFilas(rows, nombreBase) {
  const headers = ['fecha', 'puntoVenta', 'tipo', 'valor'];
  const ss = SpreadsheetApp.create(nombreBase || 'Reporte');
  const sh = ss.getActiveSheet();
  sh.setName('Reporte');

  const matrix = [headers, ...rows.map(r => [r.fecha, r.puntoVenta, r.tipo, r.valor])];
  sh.getRange(1, 1, matrix.length, headers.length).setValues(matrix);
  sh.getRange(1, 1, 1, headers.length).setFontWeight('bold');
  sh.autoResizeColumns(1, headers.length);

  const fileId = ss.getId();
  const downloadUrl = `https://docs.google.com/spreadsheets/d/${fileId}/export?format=xlsx`;
  return { fileId, downloadUrl };
}

/** ====== APERTURA DE DESTINO (DEFAULT = spreadsheet contenedor del script) ====== */
function _abrirDestinoYPreparar_() {
  const spreadsheet = SpreadsheetApp.getActive(); // ✅ default: libro que contiene el script (si es bound)
  const sheet = _getFirstSheet_(spreadsheet);

  if (!sheet) throw new Error('No se encontró ninguna hoja en el spreadsheet default.');

  const headerInfo = _leerHeaderInfo_(sheet, REQUIRED_HEADERS);

  return {
    destino: 'DEFAULT',
    spreadsheet,
    sheet,
    headerInfo
  };
}

function _getFirstSheet_(spreadsheet) {
  const sheets = spreadsheet.getSheets();
  return (sheets && sheets.length) ? sheets[SHEET_INDEX] : null;
}

function _leerHojaYCabecera_() {
  const ss = SpreadsheetApp.getActive(); // ✅ default: libro que contiene el script (si es bound)
  const sh = _getFirstSheet_(ss);
  if (!sh) throw new Error('No se encontró ninguna hoja en el spreadsheet default.');

  const data = sh.getDataRange().getValues();
  const headerRowIndex = encontrarFilaEncabezados(data, REQUIRED_HEADERS);
  if (headerRowIndex === -1) throw new Error(`No se encontraron los encabezados requeridos: ${REQUIRED_HEADERS.join(', ')}`);

  const header = data[headerRowIndex].map(v => String(v).trim());
  const idx = Object.fromEntries(REQUIRED_HEADERS.map(h => [h, header.indexOf(h)]));
  REQUIRED_HEADERS.forEach(h => { if (idx[h] === -1) throw new Error('Falta columna: ' + h); });

  return { data, headerRowIndex, idx };
}

/** ====== ESCRITURA EN HOJA ====== */
function _guardarEnHoja_(sheet, headerInfo, records) {
  if (!records || !records.length) return 0;

  const { headerRowIndex, header, colIdx, optNumIdx } = headerInfo;

  // Solo escribimos hasta la última columna que rellenamos (req + opcionales presentes).
  const maxWriteIndex = Math.max(...Object.values(colIdx), ...Object.values(optNumIdx));
  const lastColToWrite = maxWriteIndex + 1;

  const rows = [];
  for (let i = 0; i < records.length; i++) {
    const rec = records[i] || {};

    for (const h of REQUIRED_HEADERS) {
      if (!(h in rec)) throw new Error(`Falta el campo requerido "${h}" en el registro ${i + 1}`);
    }

    // valor obligatorio
    let v = rec.valor;
    if (typeof v === 'string') {
      v = v.replace(/\s/g, '').replace(/\./g, '').replace(',', '.');
      v = parseFloat(v);
    }
    if (typeof v !== 'number' || !isFinite(v)) v = 0;

    const row = new Array(lastColToWrite).fill('');

    row[colIdx.fecha]      = rec.fecha;
    row[colIdx.puntoVenta] = rec.puntoVenta;
    row[colIdx.tipo]       = rec.tipo;
    row[colIdx.tercero]    = rec.tercero;
    row[colIdx.detalle]    = rec.detalle;
    row[colIdx.valor]      = Number(v) || 0;

    // opcionales (si existen en hoja y vienen en el payload)
    for (const k in optNumIdx) {
      let n = rec[k];
      if (typeof n === 'string') {
        n = n.replace(/\s/g, '').replace(/\./g, '').replace(',', '.');
        n = parseFloat(n);
      }
      if (typeof n !== 'number' || !isFinite(n)) n = 0;
      row[optNumIdx[k]] = Number(n) || 0;
    }

    rows.push(row);
  }

  // Inserta a partir de la primera fila libre DESPUÉS de la fila de encabezados
  const startRow = Math.max(sheet.getLastRow() + 1, headerRowIndex + 2);

  // Escribe datos
  const writeRange = sheet.getRange(startRow, 1, rows.length, rows[0].length);
  writeRange.setValues(rows);

  // Formato numérico (sin moneda) en la columna "valor"
  sheet.getRange(startRow, colIdx.valor + 1, rows.length, 1).setNumberFormat('#,##0');

  // Formato numérico opcional
  for (const k in optNumIdx) {
    sheet.getRange(startRow, optNumIdx[k] + 1, rows.length, 1).setNumberFormat('#,##0');
  }

  /**
   * ====== FORMATO (MEJORAS) ======
   * - Normaliza lo insertado (sin negrita + sin fondo) en un ancho razonable (mínimo A:J) para evitar arrastres.
   * - Aplica resalto SOLO B..G para totales (negrita) y tesorería (color).
   */

  const maxColsHoja = sheet.getMaxColumns();

  // ✅ Resalto SOLO desde la columna B hasta la G (fijo)
  const highlightStartCol = 2;                        // B
  const highlightEndCol   = Math.min(7, maxColsHoja); // G
  const highlightWidth    = Math.max(0, highlightEndCol - highlightStartCol + 1);

  // Normalización (evitar arrastres): mínimo A:J (10) o el ancho real de datos/cabecera
  const normalizeWidth = Math.min(
    Math.max(header.length || 0, lastColToWrite, 10),
    maxColsHoja
  );

  // 1) Todo lo nuevo: sin negrita y sin fondo (A .. normalizeWidth)
  sheet.getRange(startRow, 1, rows.length, normalizeWidth).setFontWeight('normal');
  sheet.getRange(startRow, 1, rows.length, normalizeWidth).setBackground(null);

  // 2) Totales: negrita SOLO B..G. Tesorería: además color SOLO B..G.
  for (let i = 0; i < records.length; i++) {
    const tipoRaw = String((records[i] || {}).tipo || '').trim();
    const tipoNorm = _normText(tipoRaw);
    if (!TOTALES_NORM.has(tipoNorm)) continue;

    const rowNumber = startRow + i;

    if (highlightWidth > 0) {
      const rangoResalto = sheet.getRange(rowNumber, highlightStartCol, 1, highlightWidth);
      rangoResalto.setFontWeight('bold');

      if (tipoNorm === TIPO_TESORERIA_NORM) {
        rangoResalto.setBackgroundRGB(
          COLOR_TESORERIA_RGB.r,
          COLOR_TESORERIA_RGB.g,
          COLOR_TESORERIA_RGB.b
        );
      }
    }
  }

  return rows.length;
}

/** ====== LECTURA DE CABECERA ====== */
function _leerHeaderInfo_(sheet, requiredHeaders) {
  const data = sheet.getDataRange().getValues();
  const headerRowIndex = encontrarFilaEncabezados(data, requiredHeaders);
  if (headerRowIndex === -1) {
    throw new Error('No se encontraron los encabezados requeridos en la hoja "' + sheet.getName() + '": ' + requiredHeaders.join(', '));
  }

  const header = data[headerRowIndex].map(v => String(v).trim());

  const colIdx = Object.fromEntries(requiredHeaders.map(h => [h, header.indexOf(h)]));
  requiredHeaders.forEach(h => { if (colIdx[h] === -1) throw new Error('Falta columna en hoja "' + sheet.getName() + '": ' + h); });

  const optNumIdx = {};
  OPTIONAL_NUM_HEADERS.forEach(h => {
    const ix = header.indexOf(h);
    if (ix !== -1) optNumIdx[h] = ix;
  });

  return { data, headerRowIndex, header, colIdx, optNumIdx };
}

/** ====== UTILIDADES ====== */
function encontrarFilaEncabezados(matrix, required) {
  for (let i = 0; i < Math.min(matrix.length, 15); i++) {
    const set = new Set(matrix[i].map(v => String(v).trim()));
    if (required.every(h => set.has(h))) return i;
  }
  return -1;
}

function _json(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function _parseYMD(val) {
  if (!val) return null;
  const s = String(val).trim();
  const m = s.match(/^(\d{4})[-/](\d{2})[-/](\d{2})$/);
  if (!m) return null;
  const d = new Date(`${m[1]}-${m[2]}-${m[3]}T00:00:00`);
  return isNaN(d) ? null : d;
}
function _dayStart(iso, tz) {
  const d = _parseYMD(iso);
  if (!d) return new Date('invalid');
  const s = Utilities.formatDate(d, tz, 'yyyy-MM-dd') + ' 00:00:00';
  return new Date(s);
}
function _dayEnd(iso, tz) {
  const d = _parseYMD(iso);
  if (!d) return new Date('invalid');
  const s = Utilities.formatDate(d, tz, 'yyyy-MM-dd') + ' 23:59:59';
  return new Date(s);
}
function _coerceFecha(raw) {
  return raw instanceof Date ? raw : _parseYMD(raw);
}
function _toNumber(v) {
  if (typeof v === 'string') {
    v = v.replace(/\s/g, '').replace(/\./g, '').replace(',', '.');
    v = parseFloat(v);
  }
  if (typeof v !== 'number' || !isFinite(v)) v = 0;
  return Number(v) || 0;
}

// ✅ Normaliza textos para comparaciones seguras (quita tildes, minúsculas, colapsa espacios)
function _normText(s) {
  return String(s || '')
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}
