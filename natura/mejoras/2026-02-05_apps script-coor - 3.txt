// ===================== CONFIGURACIÃ“N =====================
const SPREADSHEET_ID = "1vxxTu4HWcgDm2HcCwPykMXyepVAFQcFsQkHUS6ed81g";
const SHEET_NAME = ""; // vacÃ­o = primera hoja
const TZ = "America/Bogota";

/**
 * âœ… MODO POR DEFECTO DEL SERVIDOR:
 * - "PING": guarda 1 fila por cada request (abrir + cada X min)
 * - "LOAD": guarda 1 fila por cada carga (dedup por load_id si llega)
 */
const SERVER_DEFAULT_MODE = "PING"; // "PING" o "LOAD"

/**
 * âœ… Si el HTML manda ?mode=PING o ?mode=LOAD, lo respetamos.
 */
const RESPECT_CLIENT_MODE_PARAM = true;

/**
 * âœ… DirecciÃ³n (reverse geocoding)
 */
const WRITE_ADDRESS = true;                 // true = llena columna "direccion"
const ADDRESS_CACHE_SECONDS = 21600;        // 6 horas
const ADDRESS_CACHE_EMPTY_SECONDS = 120;    // 2 min si sale vacÃ­a

/**
 * Encabezados requeridos (se crean si no existen).
 * (Incluye geo_status para diagnosticar por quÃ© "direccion" queda vacÃ­a)
 */
const REQUIRED_HEADERS = [
  "coordenadas",
  "direccion",
  "geo_status",
  "fecha",
  "hora",
  "minutos",
  "accuracy",
  "mode",
  "load_id",
  "visit_id",
  "timestamp_ms",
  "user_agent"
];

// ===================== ENDPOINTS =====================
function doGet(e)  { return handleRequest_(e); }
function doPost(e) { return handleRequest_(e); }

// Ejecuta esta funciÃ³n 1 vez desde el editor para autorizar permisos:
function authTest(){
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = SHEET_NAME ? ss.getSheetByName(SHEET_NAME) : ss.getSheets()[0];
  if (!sh) return;
  sh.getRange(1,1).getValue();
}

// âœ… Ejecuta 1 vez para autorizar geocoder (si WRITE_ADDRESS=true)
function geoAuthTest(){
  const res = Maps.newGeocoder()
    .setLanguage("es")
    .setRegion("co")
    .reverseGeocode(4.7110, -74.0721);
  Logger.log(JSON.stringify(res));
}

// ===================== LÃ“GICA PRINCIPAL =====================
function handleRequest_(e){
  let lock = null;

  try{
    const p = parseParams_(e);

    const lat = toNum_(p.lat);
    const lng = toNum_(p.lng);
    const acc = toNum_(p.acc);

    // Sin coords vÃ¡lidas -> ok silencioso
    if (!isFinite(lat) || !isFinite(lng)) return ok_();

    const modeClient = String(p.mode || "").toUpperCase().trim();
    const mode = (RESPECT_CLIENT_MODE_PARAM && (modeClient === "PING" || modeClient === "LOAD"))
      ? modeClient
      : String(SERVER_DEFAULT_MODE || "PING").toUpperCase();

    const loadId  = String(p.load_id || "").trim();  // id por carga (HTML)
    const visitId = String(p.visit_id || "").trim(); // por si lo usas luego

    lock = LockService.getScriptLock();
    if (!lock.tryLock(2000)) return ok_();

    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sh = SHEET_NAME ? ss.getSheetByName(SHEET_NAME) : ss.getSheets()[0];
    if (!sh) return ok_();

    // Asegurar encabezados y mapear columnas
    const headerIndex = ensureHeaders_(sh, REQUIRED_HEADERS);

    // âœ… DEDUP para LOAD: si ya existe load_id, no escribimos otra fila
    if (mode === "LOAD" && loadId && headerIndex.load_id != null){
      if (alreadyLoggedByLoadId_(sh, headerIndex.load_id + 1, loadId)){
        return ok_();
      }
    }

    const now = new Date();
    const dateStr   = Utilities.formatDate(now, TZ, "yyyy-MM-dd");
    const timeStr   = Utilities.formatDate(now, TZ, "HH:mm");
    const minuteStr = Utilities.formatDate(now, TZ, "mm");

    const coordText = `${lat.toFixed(6)},${lng.toFixed(6)}`;
    const mapsUrl   = `https://www.google.com/maps?q=${encodeURIComponent(coordText)}`;

    // DirecciÃ³n (opcional) + status diagnÃ³stico
    let address = "";
    let geoStatus = "";
    if (WRITE_ADDRESS){
      const geo = reverseGeocodeCached_(lat, lng);
      address = geo.address || "";
      geoStatus = geo.status || "";
    }

    const lastCol = sh.getLastColumn();
    const row = new Array(lastCol).fill("");

    if (headerIndex.fecha != null)        row[headerIndex.fecha]        = dateStr;
    if (headerIndex.hora != null)         row[headerIndex.hora]         = timeStr;
    if (headerIndex.minutos != null)      row[headerIndex.minutos]      = minuteStr;
    if (headerIndex.direccion != null)    row[headerIndex.direccion]    = address;
    if (headerIndex.geo_status != null)   row[headerIndex.geo_status]   = geoStatus;
    if (headerIndex.accuracy != null)     row[headerIndex.accuracy]     = isFinite(acc) ? String(acc) : "";
    if (headerIndex.mode != null)         row[headerIndex.mode]         = mode;
    if (headerIndex.load_id != null)      row[headerIndex.load_id]      = loadId;
    if (headerIndex.visit_id != null)     row[headerIndex.visit_id]     = visitId;
    if (headerIndex.timestamp_ms != null) row[headerIndex.timestamp_ms] = String(Date.now());
    if (headerIndex.user_agent != null)   row[headerIndex.user_agent]   = String(p.ua || p.user_agent || "");

    const nextRow = Math.max(2, sh.getLastRow() + 1);
    sh.getRange(nextRow, 1, 1, lastCol).setValues([row]);

    // Coordenadas como hipervÃ­nculo REAL (no fÃ³rmula)
    if (headerIndex.coordenadas != null){
      const cell = sh.getRange(nextRow, headerIndex.coordenadas + 1);
      const rich = SpreadsheetApp.newRichTextValue()
        .setText(coordText)
        .setLinkUrl(mapsUrl)
        .build();
      cell.setRichTextValue(rich);
    }

    // Cachear load_id escrito (para dedup rÃ¡pido)
    if (mode === "LOAD" && loadId){
      try{
        CacheService.getScriptCache().put("load_" + loadId, "1", 21600); // 6h
      }catch(_){}
    }

  }catch(err){
    // Silencio total
  }finally{
    try{ if (lock) lock.releaseLock(); }catch(_){}
  }

  return ok_();
}

// ===================== RESPUESTA OK =====================
function ok_(){
  return ContentService
    .createTextOutput("ok")
    .setMimeType(ContentService.MimeType.TEXT);
}

// ===================== PARSEO PARAMS =====================
function parseParams_(e){
  const out = Object.assign({}, (e && e.parameter) || {});
  try{
    const raw = e && e.postData && e.postData.contents;
    if (!raw) return out;

    const ct = String(e.postData.type || "").toLowerCase();
    if (ct.includes("application/json")){
      const j = JSON.parse(raw);
      if (j && typeof j === "object"){
        Object.keys(j).forEach(k => out[k] = String(j[k]));
      }
      return out;
    }

    raw.split("&").forEach(part => {
      if(!part) return;
      const kv = part.split("=");
      const k = kv[0];
      const v = kv.slice(1).join("=");
      if(!k) return;
      out[decodeURIComponent(k)] = decodeURIComponent(v || "");
    });
  }catch(_){}
  return out;
}

function toNum_(x){ return Number(x); }

// ===================== HEADERS =====================
function norm_(s){
  return String(s || "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .trim()
    .replace(/\s+/g, " ");
}

function ensureHeaders_(sh, required){
  const lastCol = Math.max(1, sh.getLastColumn());
  const headerRow = sh.getRange(1, 1, 1, lastCol).getValues()[0];

  const idx = {};
  headerRow.forEach((h, i) => idx[norm_(h)] = i);

  let changed = false;
  const extended = headerRow.slice();

  required.forEach(h => {
    const key = norm_(h);
    if (idx[key] == null){
      extended.push(h);
      idx[key] = extended.length - 1;
      changed = true;
    }
  });

  if (changed){
    sh.getRange(1, 1, 1, extended.length).setValues([extended]);
  }

  return {
    coordenadas:  idx[norm_("coordenadas")],
    direccion:    idx[norm_("direccion")],
    geo_status:   idx[norm_("geo_status")],
    fecha:        idx[norm_("fecha")],
    hora:         idx[norm_("hora")],
    minutos:      idx[norm_("minutos")],
    accuracy:     idx[norm_("accuracy")],
    mode:         idx[norm_("mode")],
    load_id:      idx[norm_("load_id")],
    visit_id:     idx[norm_("visit_id")],
    timestamp_ms: idx[norm_("timestamp_ms")],
    user_agent:   idx[norm_("user_agent")]
  };
}

// ===================== DEDUP LOAD =====================
/**
 * âœ… Dedup para modo LOAD: evita 2 filas con el mismo load_id.
 * - Primero revisa Cache (rÃ¡pido)
 * - Si no, escanea las Ãºltimas N filas de la columna load_id
 */
function alreadyLoggedByLoadId_(sh, loadIdCol1Based, loadId){
  try{
    const cache = CacheService.getScriptCache();
    const hit = cache.get("load_" + loadId);
    if (hit) return true;
  }catch(_){}

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return false;

  const N = 800; // escaneo de Ãºltimas 800 filas (ajÃºstalo si quieres)
  const start = Math.max(2, lastRow - N + 1);
  const num = lastRow - start + 1;

  const values = sh.getRange(start, loadIdCol1Based, num, 1).getValues();
  for (let i = values.length - 1; i >= 0; i--){
    if (String(values[i][0] || "").trim() === loadId){
      try{
        CacheService.getScriptCache().put("load_" + loadId, "1", 21600);
      }catch(_){}
      return true;
    }
  }
  return false;
}

// ===================== REVERSE GEOCODING + CACHE =====================
/**
 * âœ… Reverse geocode con cache y diagnÃ³stico de estado.
 * IMPORTANTE: usamos toFixed(4) para que el cache funcione con el â€œjitterâ€ del GPS.
 * 4 decimales â‰ˆ 11 metros.
 */
function reverseGeocodeCached_(lat, lng){
  try{
    const cache = CacheService.getScriptCache();

    // ðŸ”§ Clave con menos precisiÃ³n para que el cache sÃ­ pegue
    const key = "addr_" + lat.toFixed(4) + "_" + lng.toFixed(4);

    const cached = cache.get(key);
    if (cached != null){
      const sep = cached.indexOf("|");
      if (sep >= 0){
        return { status: cached.slice(0, sep), address: cached.slice(sep + 1) };
      }
      return { status: "CACHED", address: cached };
    }

    const res = Maps.newGeocoder()
      .setLanguage("es")
      .setRegion("co")
      .reverseGeocode(lat, lng);

    const status = String(res && res.status ? res.status : "");
    let addr = "";

    if (status === "OK" && res.results && res.results.length){
      addr = res.results[0].formatted_address || "";
    }

    const toStore = status + "|" + addr;
    cache.put(key, toStore, addr ? ADDRESS_CACHE_SECONDS : ADDRESS_CACHE_EMPTY_SECONDS);

    return { status: status || "NO_STATUS", address: addr };
  }catch(e){
    return { status: "EXCEPTION", address: "" };
  }
}
