// ===================== CONFIGURACI√ìN =====================
const SPREADSHEET_ID = "1vxxTu4HWcgDm2HcCwPykMXyepVAFQcFsQkHUS6ed81g";
const SHEET_NAME = ""; // vac√≠o = primera hoja
const TZ = "America/Bogota";

// ‚úÖ Direcci√≥n (reverse geocoding)
const WRITE_ADDRESS = true;
const ADDRESS_CACHE_SECONDS = 21600;       // 6h
const ADDRESS_CACHE_EMPTY_SECONDS = 120;   // 2min si sale vac√≠a

// ‚úÖ SOLO estas columnas se crear√°n/escribir√°n (ya NO salen las otras)
const REQUIRED_HEADERS = [
  "coordenadas",
  "direccion",
  "fecha",
  "hora",
  "minutos"
];

// ‚úÖ (Opcional) Columnas que quieres eliminar de la hoja existente
const UNWANTED_HEADERS = [
  "geo_status",
  "accuracy",
  "mode",
  "load_id",
  "visit_id",
  "timestamp_ms",
  "user_agent"
];

// ===================== ENDPOINTS =====================
function doGet(e)  { return handleRequest_(e); }
function doPost(e) { return handleRequest_(e); }

// Ejecuta 1 vez desde el editor para autorizar Spreadsheet
function authTest(){
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = SHEET_NAME ? ss.getSheetByName(SHEET_NAME) : ss.getSheets()[0];
  if (!sh) return;
  sh.getRange(1, 1).getValue();
}

// ‚úÖ Ejecuta 1 vez para autorizar Maps (si WRITE_ADDRESS=true)
function geoAuthTest(){
  const res = Maps.newGeocoder()
    .setLanguage("es")
    .setRegion("co")
    .reverseGeocode(4.7110, -74.0721);
  Logger.log(JSON.stringify(res));
}

// ===================== L√ìGICA PRINCIPAL =====================
function handleRequest_(e){
  let lock = null;

  try{
    const p = parseParams_(e);

    const lat = Number(p.lat);
    const lng = Number(p.lng);

    // sin coords v√°lidas -> ok silencioso
    if (!isFinite(lat) || !isFinite(lng)) return ok_();

    lock = LockService.getScriptLock();
    if (!lock.tryLock(2000)) return ok_();

    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sh = SHEET_NAME ? ss.getSheetByName(SHEET_NAME) : ss.getSheets()[0];
    if (!sh) return ok_();

    const headerIndex = ensureHeaders_(sh, REQUIRED_HEADERS);
    const lastCol = sh.getLastColumn();

    const now = new Date();
    const dateStr   = Utilities.formatDate(now, TZ, "yyyy-MM-dd");
    const timeStr   = Utilities.formatDate(now, TZ, "HH:mm");
    const minuteStr = Utilities.formatDate(now, TZ, "mm");

    const coordText = `${lat.toFixed(6)},${lng.toFixed(6)}`;
    const mapsUrl   = `https://www.google.com/maps?q=${encodeURIComponent(coordText)}`;

    let address = "";
    if (WRITE_ADDRESS){
      const geo = reverseGeocodeCached_(lat, lng);
      address = geo.address || "";
    }

    const row = new Array(lastCol).fill("");
    if (headerIndex.fecha != null)      row[headerIndex.fecha]      = dateStr;
    if (headerIndex.hora != null)       row[headerIndex.hora]       = timeStr;
    if (headerIndex.minutos != null)    row[headerIndex.minutos]    = minuteStr;
    if (headerIndex.direccion != null)  row[headerIndex.direccion]  = address;

    const nextRow = Math.max(2, sh.getLastRow() + 1);
    sh.getRange(nextRow, 1, 1, lastCol).setValues([row]);

    // Coordenadas como hiperv√≠nculo REAL
    if (headerIndex.coordenadas != null){
      const cell = sh.getRange(nextRow, headerIndex.coordenadas + 1);
      const rich = SpreadsheetApp.newRichTextValue()
        .setText(coordText)
        .setLinkUrl(mapsUrl)
        .build();
      cell.setRichTextValue(rich);
    }

  }catch(_){
    // silencio total
  }finally{
    try{ if (lock) lock.releaseLock(); }catch(_){}
  }

  return ok_();
}

// ===================== RESPUESTA OK =====================
function ok_(){
  return ContentService
    .createTextOutput("ok")
    .setMimeType(ContentService.MimeType.TEXT);
}

// ===================== PARSEO PARAMS =====================
function parseParams_(e){
  const out = Object.assign({}, (e && e.parameter) || {});
  try{
    const raw = e && e.postData && e.postData.contents;
    if (!raw) return out;

    const ct = String(e.postData.type || "").toLowerCase();
    if (ct.includes("application/json")){
      const j = JSON.parse(raw);
      if (j && typeof j === "object"){
        Object.keys(j).forEach(k => out[k] = String(j[k]));
      }
      return out;
    }

    raw.split("&").forEach(part => {
      if(!part) return;
      const kv = part.split("=");
      const k = kv[0];
      const v = kv.slice(1).join("=");
      if(!k) return;
      out[decodeURIComponent(k)] = decodeURIComponent(v || "");
    });
  }catch(_){}
  return out;
}

// ===================== HEADERS =====================
function norm_(s){
  return String(s || "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .trim()
    .replace(/\s+/g, " ");
}

function ensureHeaders_(sh, required){
  const lastCol = Math.max(1, sh.getLastColumn());
  const headerRow = sh.getRange(1, 1, 1, lastCol).getValues()[0];

  const idx = {};
  headerRow.forEach((h, i) => idx[norm_(h)] = i);

  let changed = false;
  const extended = headerRow.slice();

  required.forEach(h => {
    const key = norm_(h);
    if (idx[key] == null){
      extended.push(h);
      idx[key] = extended.length - 1;
      changed = true;
    }
  });

  if (changed){
    sh.getRange(1, 1, 1, extended.length).setValues([extended]);
  }

  return {
    coordenadas: idx[norm_("coordenadas")],
    direccion:   idx[norm_("direccion")],
    fecha:       idx[norm_("fecha")],
    hora:        idx[norm_("hora")],
    minutos:     idx[norm_("minutos")]
  };
}

// ===================== REVERSE GEOCODING + CACHE =====================
function reverseGeocodeCached_(lat, lng){
  try{
    const cache = CacheService.getScriptCache();

    // üîß menos precisi√≥n para que el cache funcione con jitter del GPS (‚âà11m)
    const key = "addr_" + lat.toFixed(4) + "_" + lng.toFixed(4);

    const cached = cache.get(key);
    if (cached != null){
      const sep = cached.indexOf("|");
      if (sep >= 0) return { status: cached.slice(0, sep), address: cached.slice(sep + 1) };
      return { status: "CACHED", address: cached };
    }

    const res = Maps.newGeocoder()
      .setLanguage("es")
      .setRegion("co")
      .reverseGeocode(lat, lng);

    const status = String(res && res.status ? res.status : "");
    let addr = "";

    if (status === "OK" && res.results && res.results.length){
      addr = res.results[0].formatted_address || "";
    }

    const toStore = status + "|" + addr;
    cache.put(key, toStore, addr ? ADDRESS_CACHE_SECONDS : ADDRESS_CACHE_EMPTY_SECONDS);

    return { status: status || "NO_STATUS", address: addr };
  }catch(_){
    return { status: "EXCEPTION", address: "" };
  }
}

// ===================== UTIL: PARSEAR "lat,lng" =====================
function parseCoordText_(s){
  const txt = String(s || "").trim();
  if (!txt) return null;

  // extrae los primeros 2 n√∫meros (lat y lng)
  const m = txt.match(/-?\d+(?:\.\d+)?/g);
  if (!m || m.length < 2) return null;

  const lat = Number(m[0]);
  const lng = Number(m[1]);
  if (!isFinite(lat) || !isFinite(lng)) return null;

  return { lat, lng };
}

// ===================== 1) RELLENAR DIRECCIONES VIEJAS =====================
/**
 * Rellena "direccion" en filas existentes donde est√© vac√≠a,
 * usando la columna "coordenadas".
 *
 * - Procesa en lotes para evitar l√≠mites de tiempo/cuota.
 * - Ejecutar varias veces hasta terminar.
 */
function fillMissingAddresses(){
  const BATCH_SIZE = 200; // ajusta si quieres (100-300 suele ir bien)

  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = SHEET_NAME ? ss.getSheetByName(SHEET_NAME) : ss.getSheets()[0];
  if (!sh) return;

  const headerIndex = ensureHeaders_(sh, REQUIRED_HEADERS);
  if (headerIndex.coordenadas == null || headerIndex.direccion == null) return;

  const coordCol = headerIndex.coordenadas + 1;
  const dirCol   = headerIndex.direccion + 1;

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;

  // Para continuar donde qued√≥ (si hay muchas filas)
  const props = PropertiesService.getScriptProperties();
  let startRow = Number(props.getProperty("BACKFILL_NEXT_ROW") || "2");
  if (startRow < 2) startRow = 2;
  if (startRow > lastRow) {
    props.deleteProperty("BACKFILL_NEXT_ROW");
    return;
  }

  const endRow = Math.min(lastRow, startRow + BATCH_SIZE - 1);
  const numRows = endRow - startRow + 1;

  // Nota: coordenadas son RichText; getDisplayValues() devuelve el texto visible "lat,lng"
  const coords = sh.getRange(startRow, coordCol, numRows, 1).getDisplayValues();
  const dirs   = sh.getRange(startRow, dirCol,   numRows, 1).getValues();

  let changed = false;

  for (let i = 0; i < numRows; i++){
    const currentDir = String(dirs[i][0] || "").trim();
    if (currentDir) continue; // ya tiene direcci√≥n

    const coordText = String(coords[i][0] || "").trim();
    const parsed = parseCoordText_(coordText);
    if (!parsed) continue;

    const geo = reverseGeocodeCached_(parsed.lat, parsed.lng);
    const addr = String(geo.address || "").trim();
    if (addr){
      dirs[i][0] = addr;
      changed = true;
    }
  }

  if (changed){
    sh.getRange(startRow, dirCol, numRows, 1).setValues(dirs);
  }

  // Guardar punto de continuaci√≥n
  if (endRow >= lastRow){
    props.deleteProperty("BACKFILL_NEXT_ROW");
  }else{
    props.setProperty("BACKFILL_NEXT_ROW", String(endRow + 1));
  }
}

/** Si quieres reiniciar el relleno desde la fila 2 */
function resetBackfill(){
  PropertiesService.getScriptProperties().deleteProperty("BACKFILL_NEXT_ROW");
}

// ===================== 2) (OPCIONAL) BORRAR COLUMNAS QUE NO QUIERES =====================
/**
 * Borra columnas por encabezado (fila 1).
 * ‚ö†Ô∏è IRREVERSIBLE: haz copia de la hoja antes.
 */
function removeUnwantedColumns(){
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = SHEET_NAME ? ss.getSheetByName(SHEET_NAME) : ss.getSheets()[0];
  if (!sh) return;

  const lastCol = sh.getLastColumn();
  if (lastCol < 1) return;

  const headerRow = sh.getRange(1, 1, 1, lastCol).getValues()[0];
  const unwantedSet = new Set(UNWANTED_HEADERS.map(h => norm_(h)));

  // obtener √≠ndices a borrar (0-based)
  const colsToDelete = [];
  for (let i = 0; i < headerRow.length; i++){
    const key = norm_(headerRow[i]);
    if (unwantedSet.has(key)) colsToDelete.push(i + 1); // 1-based
  }

  // borrar de derecha a izquierda para no desfasar
  colsToDelete.sort((a, b) => b - a).forEach(col1Based => {
    sh.deleteColumn(col1Based);
  });
}
