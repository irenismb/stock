<!doctype html>
<html lang="es">
<head>
  <base target="_top">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#0b1020" />
  <title>Notas</title>

  <style>
    :root{
      --bg: #0b1020;
      --panel: rgba(17,26,51,.55);
      --panel2: rgba(17,26,51,.35);
      --text: #e8eeff;
      --muted: #a7b3dd;
      --line: rgba(255,255,255,.10);

      /* ✅ PALETA PRO */
      --fluor-blue:  #4F46E5;
      --fluor-blue2: #818CF8;

      --fluor-orange:  #F59E0B;
      --fluor-orange2: #FBBF24;

      --danger:  #EF4444;
      --danger2: #F87171;

      --ok:  #10B981;
      --ok2: #34D399;

      --btn:  #1F2A44;
      --btn2: #2B3A5E;

      --mark: rgba(255, 210, 0, .24);

      --btn-fixed-width: 44px;
      --radius: 12px;
    }

    [data-theme="light"]{
      --bg: #f7f8fc;
      --panel: rgba(255,255,255,.75);
      --panel2: rgba(255,255,255,.55);
      --text: #101428;
      --muted: #4a587e;
      --line: rgba(16,20,40,.12);

      --btn: #e7ebff;
      --btn2:#f2f4ff;

      --mark: rgba(255, 200, 0, .22);
    }

    *{ box-sizing: border-box; }

    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(21,34,74,.9) 0%, var(--bg) 55%, rgba(7,10,20,.95) 100%);
    }

    [data-theme="light"] body{
      background: radial-gradient(1200px 600px at 20% 0%, rgba(140,165,255,.35) 0%, var(--bg) 55%, rgba(255,255,255,.9) 100%);
    }

    /* ✅ evita selección durante drag táctil */
    body.dragging-no-select, body.dragging-no-select *{
      user-select: none !important;
      -webkit-user-select: none !important;
    }

    .app{
      max-width: 1080px;
      margin: 18px auto;
      padding: 14px;
    }

    /* ✅ Header simplificado: contador + búsqueda + controles EN LA MISMA FILA (desktop) */
    .header{
      margin-bottom: 12px;
    }

    .topbar{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }

    .countbox{
      display:flex;
      align-items:center;
      flex: 0 0 auto;
      min-width: 90px;
    }

    .count{
      color: var(--muted);
      font-size: 13px;
      white-space:nowrap;
    }

    .search{
      display:flex;
      gap:10px;
      align-items:center;
      flex: 1 1 420px;
      justify-content:flex-start;
      min-width: 260px;
    }

    .search label{
      color: var(--muted);
      font-size: 13px;
      user-select:none;
      white-space:nowrap;
    }

    .searchbox{
      display:flex;
      align-items:stretch;
      width: 100%;
      max-width: 560px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }

    [data-theme="light"] .searchbox{
      background: rgba(255,255,255,.8);
    }

    .search input{
      width: 100%;
      padding: 10px 12px;
      border: none;
      outline:none;
      background: transparent;
      color: var(--text);
    }

    .searchbox:focus-within{
      border-color: rgba(0,183,255,.55);
      box-shadow: 0 0 0 3px rgba(0,183,255,.18);
    }

    .icon-btn{
      width: 44px;
      border: none;
      cursor:pointer;
      background: transparent;
      color: var(--muted);
      font-size: 22px;
      line-height: 1;
    }
    .icon-btn:hover{ color: var(--text); }

    .toolbar{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
      flex: 0 0 auto;
      flex-wrap:wrap;
    }

    .select{
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
    }

    [data-theme="light"] .select{
      background: rgba(255,255,255,.8);
    }

    .select:focus{
      border-color: rgba(0,183,255,.55);
      box-shadow: 0 0 0 3px rgba(0,183,255,.18);
    }

    .select option{
      color: #000;
      background: #fff;
    }

    .btn{
      width: var(--btn-fixed-width);
      min-width: var(--btn-fixed-width);
      height: 44px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      color: var(--text);
      padding: 0;
      border-radius: 10px;
      cursor:pointer;
      user-select:none;
      transition: transform .05s ease, filter .15s ease, box-shadow .15s ease, border-color .15s ease;
      font-weight: 650;
      letter-spacing: .2px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      white-space:nowrap;
      overflow:hidden;
    }
    .btn:active{ transform: translateY(1px); }
    .btn:hover{ filter: brightness(1.08); }

    .btn svg{
      width: 20px;
      height: 20px;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      flex: 0 0 auto;
    }

    .btn-add{
      border-color: rgba(129,140,248,.85);
      background: linear-gradient(180deg, var(--fluor-blue2), var(--fluor-blue));
      color: #ffffff;
      box-shadow: 0 0 18px rgba(79,70,229,.22);
    }

    .btn-copy{
      border-color: rgba(16,185,129,.70);
      background: linear-gradient(180deg, var(--ok2), var(--ok));
      color: #052014;
      box-shadow: 0 0 16px rgba(16,185,129,.20);
    }

    .btn-paste{
      border-color: rgba(245,158,11,.80);
      background: linear-gradient(180deg, var(--fluor-orange2), var(--fluor-orange));
      color: #1a1200;
      box-shadow: 0 0 18px rgba(245,158,11,.20);
    }

    .btn-danger{
      border-color: rgba(239,68,68,.75);
      background: linear-gradient(180deg, var(--danger2), var(--danger));
      color: #ffffff;
      box-shadow: 0 0 16px rgba(239,68,68,.20);
    }

    .btn-ghost{
      background: rgba(0,0,0,.12);
      border-color: rgba(255,255,255,.14);
      box-shadow: none;
    }

    [data-theme="light"] .btn-ghost{
      background: rgba(255,255,255,.55);
    }

    .list{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      overflow:hidden;
    }

    .section{
      border-top: 1px solid var(--line);
    }
    .section:first-child{ border-top:none; }

    .section-title{
      padding: 10px 12px;
      font-weight: 700;
      letter-spacing:.2px;
      color: var(--muted);
      background: var(--panel2);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .section-body{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    /* ✅ Categorías */
    .cat-group{
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow:hidden;
      background: rgba(0,0,0,.10);
    }
    [data-theme="light"] .cat-group{
      background: rgba(255,255,255,.55);
    }

    .cat-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      background: var(--panel2);
    }

    .cat-left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }

    .cat-toggle{
      width: 34px;
      height: 34px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.12);
      color: var(--muted);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      flex: 0 0 auto;
    }
    .cat-toggle:hover{ color: var(--text); }
    .cat-toggle svg{ width: 18px; height: 18px; }

    .cat-name{
      font-weight: 750;
      letter-spacing: .2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width: 0;
    }

    .cat-pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--text);
      background: rgba(0,0,0,.12);
      flex: 0 0 auto;
      font-size: 12px;
      font-weight: 700;
    }

    .cat-dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.22);
      flex: 0 0 auto;
    }
    [data-theme="light"] .cat-dot{ border-color: rgba(16,20,40,.18); }

    .cat-right{
      display:flex;
      align-items:center;
      gap:8px;
      flex: 0 0 auto;
    }

    .cat-list{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .cat-group.collapsed .cat-list{
      display:none;
    }

    .cat-empty{
      padding: 10px 12px;
      border: 1px dashed var(--line);
      border-radius: 12px;
      color: var(--muted);
      background: rgba(0,0,0,.10);
      font-size: 13px;
      text-align:center;
    }
    [data-theme="light"] .cat-empty{
      background: rgba(255,255,255,.45);
    }

    .note{
      display:grid;
      grid-template-columns: 34px 1fr auto;
      gap: 10px;
      align-items:stretch;
      padding: 10px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(0,0,0,.12);
    }

    [data-theme="light"] .note{
      background: rgba(255,255,255,.55);
    }

    .note[hidden]{ display:none; }

    .drag-handle{
      border: 1px solid var(--line);
      background: rgba(0,0,0,.12);
      border-radius: 10px;
      cursor: grab;
      color: var(--muted);
      font-size: 18px;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;

      /* ✅ móvil */
      touch-action: none;
      -webkit-touch-callout: none;
    }
    .drag-handle:active{ cursor: grabbing; }
    .drag-handle:hover{ color: var(--text); }

    .note.dragging{
      opacity:.55;
      outline: 2px dashed rgba(0,183,255,.45);
      outline-offset: 2px;
    }

    .note.placeholder{
      background: transparent !important;
      border: 2px dashed rgba(0,183,255,.45) !important;
    }

    .note.dragging-touch{
      opacity: .92;
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      pointer-events: none;
      transform: rotate(.2deg);
    }

    .content{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 220px;
    }

    .note-view{
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      cursor:text;
      line-height: 1.4;
      word-break: break-word;

      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    [data-theme="light"] .note-view{
      background: rgba(255,255,255,.75);
    }

    .note-view:focus{
      outline:none;
      border-color: rgba(0,255,153,.40);
      box-shadow: 0 0 0 3px rgba(0,255,153,.12);
    }

    .note-view .placeholder{
      color: var(--muted);
    }

    .note-edit{
      display:none;
      width:100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
      resize:none;
      overflow:hidden;
      line-height: 1.4;
      min-height: 44px;
    }

    [data-theme="light"] .note-edit{
      background: rgba(255,255,255,.75);
    }

    .note.editing .note-view{ display:none; }
    .note.editing .note-edit{ display:block; }

    .note-edit:focus{
      border-color: rgba(0,255,153,.40);
      box-shadow: 0 0 0 3px rgba(0,255,153,.12);
    }

    .meta{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size: 12px;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.14);
      color: var(--text);
      font-weight: 700;
    }
    [data-theme="light"] .badge{ background: rgba(255,255,255,.65); }

    .badge .dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.22);
    }
    [data-theme="light"] .badge .dot{ border-color: rgba(16,20,40,.18); }

    .cat-select{
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
      font-size: 12px;
      max-width: 240px;
    }
    [data-theme="light"] .cat-select{
      background: rgba(255,255,255,.8);
    }
    .cat-select option{
      color:#000;
      background:#fff;
    }

    mark{
      background: var(--mark);
      color: inherit;
      border-radius: 4px;
      padding: 0 .12em;
    }

    .actions{
      display:flex;
      flex-direction:row;
      gap:8px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap:nowrap;
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
    }

    .actions .btn{
      flex: 0 0 auto;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.78);
      color: var(--text);
      border: 1px solid rgba(255,255,255,.16);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 13px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      max-width: min(860px, 92vw);
      display:flex;
      gap:10px;
      align-items:center;
    }

    [data-theme="light"] .toast{
      background: rgba(20,25,40,.88);
    }

    .toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(-4px);
      pointer-events:auto;
    }

    .toast .toast-btn{
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.12);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 10px;
      cursor:pointer;
      font-weight: 650;
    }

    .toast .toast-btn:hover{ filter: brightness(1.08); }

    .empty{
      padding: 18px 14px;
      text-align:center;
      color: var(--muted);
      border-top: 1px solid var(--line);
    }

    .empty-title{
      font-weight: 750;
      color: var(--text);
      margin-bottom: 4px;
    }

    .sr-only{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }

    /* ✅ Modal categorías */
    dialog.modal{
      border: none;
      padding: 0;
      border-radius: 14px;
      width: min(820px, 92vw);
      color: var(--text);
      background: rgba(10,14,28,.92);
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
      overflow:hidden;
    }
    [data-theme="light"] dialog.modal{
      background: rgba(245,247,255,.96);
      color: var(--text);
    }
    dialog::backdrop{
      background: rgba(0,0,0,.55);
    }

    .modal-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      background: var(--panel2);
    }
    .modal-title{
      font-weight: 800;
      letter-spacing: .2px;
    }
    .modal-body{
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .cat-table{
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .cat-row{
      display:grid;
      grid-template-columns: 1fr 120px 34px 34px 44px;
      gap:10px;
      align-items:center;
      padding: 10px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(0,0,0,.10);
    }
    [data-theme="light"] .cat-row{
      background: rgba(255,255,255,.65);
    }

    .cat-row input[type="text"]{
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.16);
      color: var(--text);
      outline:none;
    }
    [data-theme="light"] .cat-row input[type="text"]{
      background: rgba(255,255,255,.9);
    }

    .cat-row input[type="color"]{
      width: 100%;
      height: 40px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: transparent;
      padding: 2px;
      cursor:pointer;
    }

    .mini-btn{
      width: 34px;
      height: 34px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.12);
      color: var(--muted);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .mini-btn:hover{ color: var(--text); }
    .mini-btn[disabled]{ opacity:.35; cursor:not-allowed; }

    .cat-add{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      padding-top: 6px;
      border-top: 1px solid var(--line);
      margin-top: 4px;
    }
    .cat-add input[type="text"]{
      flex: 1 1 260px;
      min-width: 220px;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.16);
      color: var(--text);
      outline:none;
    }
    [data-theme="light"] .cat-add input[type="text"]{
      background: rgba(255,255,255,.9);
    }

    /* ✅ PC: fuerza misma fila si hay espacio */
    @media (min-width: 861px){
      .topbar{ flex-wrap:nowrap; }
      .toolbar{ flex-wrap:nowrap; }
    }

    /* ✅ MÓVIL: todo centrado */
    @media (max-width: 860px){
      .topbar{
        flex-direction:column;
        align-items:center;
        justify-content:center;
        text-align:center;
        gap: 10px;
      }

      .countbox{
        justify-content:center;
      }

      .search{
        flex: 1 1 100%;
        justify-content:center;
        align-items:center;
        flex-direction:column;
        gap: 8px;
        min-width: auto;
      }

      .search label{
        text-align:center;
      }

      .searchbox{
        width: min(560px, 100%);
        margin: 0 auto;
      }

      .toolbar{
        width: 100%;
        justify-content:center;
        align-items:center;
      }

      .select{
        width: min(320px, 100%);
        text-align-last: center;
      }

      .btn{
        width: var(--btn-fixed-width);
        min-width: var(--btn-fixed-width);
      }

      .note{
        grid-template-columns: 34px 1fr;
        grid-template-rows: auto auto;
      }

      .actions{
        grid-column: 1 / -1;
        flex-direction:row;
        flex-wrap:nowrap;
        justify-content:flex-end;
        overflow-x:auto;
      }

      .cat-row{
        grid-template-columns: 1fr 120px 34px 34px 44px;
      }
    }

    @media (prefers-reduced-motion: reduce){
      *{ transition: none !important; }
    }
  </style>
</head>

<body>
  <div class="app">
    <header class="header">
      <div class="topbar">
        <div class="countbox">
          <span id="count" class="count"></span>
        </div>

        <div class="search">
          <label for="search">Buscar</label>
          <div class="searchbox">
            <input id="search" type="text" autocomplete="off" placeholder="Escribe para filtrar… (ignora tildes)" />
            <button id="clearSearch" class="icon-btn" type="button" aria-label="Limpiar búsqueda" title="Limpiar">×</button>
          </div>
        </div>

        <div class="toolbar" role="group" aria-label="Acciones">
          <label class="sr-only" for="catFilter">Categoría</label>
          <select id="catFilter" class="select" aria-label="Filtrar por categoría"></select>

          <label class="sr-only" for="sort">Orden</label>
          <select id="sort" class="select" aria-label="Ordenar notas">
            <option value="manual">Manual (arrastrar)</option>
            <option value="updated_desc">Actualizadas (más recientes)</option>
            <option value="created_desc">Creadas (más recientes)</option>
            <option value="alpha_asc">A-Z</option>
          </select>

          <button id="catBtn" class="btn btn-ghost" type="button" aria-label="Categorías" title="Categorías">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M3 7a2 2 0 0 1 2-2h5l2 2h7a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
              <path d="M3 9h18"></path>
            </svg>
            <span class="sr-only">Categorías</span>
          </button>

          <button id="newNote" class="btn btn-add" type="button" aria-label="Nueva nota" title="Nueva nota">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
              <path d="M14 2v6h6"></path>
              <path d="M12 12v6"></path>
              <path d="M9 15h6"></path>
            </svg>
            <span class="sr-only">Nueva nota</span>
          </button>

          <button id="exportJson" class="btn" type="button" aria-label="Exportar JSON" title="Exportar JSON">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 3v10"></path>
              <path d="M8 9l4 4 4-4"></path>
              <path d="M4 17h16v4H4z"></path>
              <path d="M9 8l-2 2 2 2"></path>
              <path d="M15 8l2 2-2 2"></path>
            </svg>
            <span class="sr-only">Exportar JSON</span>
          </button>

          <button id="exportTxt" class="btn" type="button" aria-label="Exportar TXT" title="Exportar TXT">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 3v10"></path>
              <path d="M8 9l4 4 4-4"></path>
              <path d="M4 17h16v4H4z"></path>
              <path d="M7 8h10"></path>
              <path d="M7 11h8"></path>
            </svg>
            <span class="sr-only">Exportar TXT</span>
          </button>

          <input id="importFile" type="file" accept=".json,.txt,application/json,text/plain" hidden />
          <button id="importBtn" class="btn" type="button" aria-label="Importar" title="Importar">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 21V11"></path>
              <path d="M16 15l-4-4-4 4"></path>
              <path d="M4 3h16v6H4z"></path>
            </svg>
            <span class="sr-only">Importar</span>
          </button>

          <button id="themeBtn" class="btn btn-ghost" type="button" aria-label="Cambiar tema" title="Tema">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 3v2"></path>
              <path d="M12 19v2"></path>
              <path d="M4.22 4.22l1.42 1.42"></path>
              <path d="M18.36 18.36l1.42 1.42"></path>
              <path d="M3 12h2"></path>
              <path d="M19 12h2"></path>
              <path d="M4.22 19.78l1.42-1.42"></path>
              <path d="M18.36 5.64l1.42-1.42"></path>
              <path d="M12 7a5 5 0 1 0 0 10a5 5 0 0 0 0-10z"></path>
            </svg>
            <span class="sr-only">Tema</span>
          </button>
        </div>
      </div>
    </header>

    <main class="list" aria-label="Notas">
      <section id="pinnedSection" class="section" hidden>
        <div class="section-title">Fijadas</div>
        <div id="pinnedList" class="section-body"></div>
      </section>

      <section id="notesSection" class="section">
        <div class="section-title">Categorías</div>
        <div id="notesList" class="section-body"></div>
      </section>

      <div id="empty" class="empty" hidden>
        <div class="empty-title">Sin resultados</div>
        <div class="empty-sub">Prueba con otra búsqueda o crea una nota nueva.</div>
      </div>
    </main>
  </div>

  <dialog id="catDialog" class="modal" aria-label="Gestión de categorías">
    <div class="modal-head">
      <div class="modal-title">Categorías</div>
      <button id="catClose" class="btn btn-ghost" type="button" aria-label="Cerrar" title="Cerrar">
        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M6 6l12 12"></path>
          <path d="M18 6l-12 12"></path>
        </svg>
      </button>
    </div>
    <div class="modal-body">
      <div class="cat-table" id="catTable"></div>

      <div class="cat-add">
        <input id="catNewName" type="text" placeholder="Nueva categoría (ej. Trabajo)" aria-label="Nombre de la nueva categoría" />
        <input id="catNewColor" type="color" value="#64748B" aria-label="Color de la nueva categoría" />
        <button id="catAddBtn" class="btn btn-add" type="button" aria-label="Agregar categoría" title="Agregar categoría">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M12 5v14"></path>
            <path d="M5 12h14"></path>
          </svg>
        </button>
      </div>
    </div>
  </dialog>

  <div id="toast" class="toast" role="status" aria-live="polite" aria-atomic="true"></div>

  <script>
    (() => {
      "use strict";

      /* =========================
         Backend: GitHub Pages -> Apps Script Web App API
         - Lee con JSONP (GET) para evitar CORS
         - Guarda con POST vía iframe + postMessage (evita CORS)
         - ✅ SIN TOKEN (abierto)
      ========================== */

      // ✅ Pega aquí tu URL /exec del despliegue (Web App)
      // Ejemplo: https://script.google.com/macros/s/AKfycbxxxxxxxxxxxxxxxx/exec
      const API_URL = "https://script.google.com/macros/s/AKfycbw_ICKDJ0UpfZfYW3jXgugScL6-bTdvPGugfoD1wRH-nwhZKqAlW-Y6YwQmdFRULe3j/exec";

      // ✅ Si quieres cambiar el intervalo de auto-sync
      const AUTOSYNC_MS = 15000;

      function isLikelyBadApiUrl_(u) {
        const s = String(u || "");
        return !s || s.includes("XXXXXXXX") || s.includes("/macros/library/") || s.includes("/library/d/");
      }

      function jsonp_(params) {
        return new Promise((resolve, reject) => {
          if (isLikelyBadApiUrl_(API_URL)) {
            reject(new Error("Configura API_URL con tu /exec real (no /library)."));
            return;
          }

          const cb = "__jsonp_cb_" + Math.random().toString(16).slice(2);
          const url = new URL(API_URL);
          const q = new URLSearchParams(params || {});
          q.set("callback", cb);
          q.set("t", String(Date.now())); // evita cache
          url.search = q.toString();

          let done = false;
          const cleanup = () => {
            if (done) return;
            done = true;
            try { delete window[cb]; } catch {}
            script.remove();
            clearTimeout(timer);
          };

          window[cb] = (data) => { cleanup(); resolve(data); };

          const script = document.createElement("script");
          script.src = url.toString();
          script.async = true;
          script.onerror = () => { cleanup(); reject(new Error("JSONP error (revisa API_URL/deploy)")); };

          const timer = setTimeout(() => {
            cleanup();
            reject(new Error("Timeout leyendo datos (revisa Apps Script)"));
          }, 12000);

          document.head.appendChild(script);
        });
      }

      async function apiGetState_() {
        const data = await jsonp_({ action: "getState" }); // ✅ sin token
        if (data && data.ok === false) throw new Error(data.error || "Error getState");
        return data;
      }

      // Guardado por POST via iframe (sin CORS)
      const SAVE_IFRAME_NAME = "notas_save_iframe_v2";
      let saveBridgeReady = false;
      let saveBusy = false;
      let saveQueuedState = null;

      let saveIframeEl = null;
      let saveFormEl = null;
      let inActionEl = null;
      let inPayloadEl = null;

      function ensureSaveBridge_() {
        if (saveBridgeReady) return;

        if (isLikelyBadApiUrl_(API_URL)) {
          // No lanzamos error aquí para no romper la UI, solo evitamos guardar.
          return;
        }

        // iframe oculto
        saveIframeEl = document.createElement("iframe");
        saveIframeEl.name = SAVE_IFRAME_NAME;
        saveIframeEl.style.position = "fixed";
        saveIframeEl.style.left = "-9999px";
        saveIframeEl.style.top = "-9999px";
        saveIframeEl.style.width = "1px";
        saveIframeEl.style.height = "1px";
        saveIframeEl.setAttribute("aria-hidden", "true");

        // form oculto
        saveFormEl = document.createElement("form");
        saveFormEl.method = "POST";
        saveFormEl.action = API_URL;
        saveFormEl.target = SAVE_IFRAME_NAME;
        saveFormEl.acceptCharset = "utf-8";
        saveFormEl.style.position = "fixed";
        saveFormEl.style.left = "-9999px";
        saveFormEl.style.top = "-9999px";

        inActionEl = document.createElement("input");
        inActionEl.type = "hidden";
        inActionEl.name = "action";
        inActionEl.value = "saveAll";

        inPayloadEl = document.createElement("input");
        inPayloadEl.type = "hidden";
        inPayloadEl.name = "payload";

        saveFormEl.appendChild(inActionEl);
        saveFormEl.appendChild(inPayloadEl);

        document.body.appendChild(saveIframeEl);
        document.body.appendChild(saveFormEl);

        saveBridgeReady = true;
      }

      function apiSaveAllFireAndForget_(state) {
        try {
          if (isLikelyBadApiUrl_(API_URL)) return;

          ensureSaveBridge_();
          if (!saveBridgeReady) return;

          inPayloadEl.value = JSON.stringify(state);
          saveFormEl.submit();
        } catch {}
      }

      function apiSaveAll_(state) {
        // cola: siempre guarda el último estado
        saveQueuedState = state;

        if (saveBusy) return Promise.resolve({ ok: true, queued: true });

        return new Promise((resolve, reject) => {
          if (isLikelyBadApiUrl_(API_URL)) { reject(new Error("Configura API_URL")); return; }

          ensureSaveBridge_();
          if (!saveBridgeReady) { reject(new Error("No se pudo inicializar puente de guardado.")); return; }

          const runOne = () => {
            if (!saveQueuedState) { saveBusy = false; resolve({ ok: true, empty: true }); return; }
            const payloadState = saveQueuedState;
            saveQueuedState = null;

            saveBusy = true;

            // escuchar respuesta del iframe
            const onMsg = (ev) => {
              const d = ev && ev.data;
              if (!d || d.type !== "notas_saveAll") return;

              window.removeEventListener("message", onMsg);

              if (d.ok) {
                if (saveQueuedState) return runOne();
                saveBusy = false;
                resolve(d);
              } else {
                saveBusy = false;
                reject(new Error(d.error || "Error guardando"));
              }
            };

            window.addEventListener("message", onMsg);

            // timeout: si no llega postMessage, no bloqueamos la app
            const t = setTimeout(() => {
              window.removeEventListener("message", onMsg);
              if (saveQueuedState) return runOne();
              saveBusy = false;
              resolve({ ok: true, timeout: true });
            }, 12000);

            // submit
            try {
              inPayloadEl.value = JSON.stringify(payloadState);
              saveFormEl.submit();
            } catch (e) {
              clearTimeout(t);
              window.removeEventListener("message", onMsg);
              saveBusy = false;
              reject(e);
            }
          };

          runOne();
        });
      }

      /* =========================
         Storage (solo UI)
      ========================== */
      const THEME_KEY = "notas_web_theme_v1";
      const SETTINGS_KEY = "notas_web_settings_v1";

      /* =========================
         Model
      ========================== */
      const GENERAL_CATEGORY_ID = "general";
      const DEFAULT_GENERAL_CATEGORY = {
        id: GENERAL_CATEGORY_ID,
        name: "General",
        color: "#64748B",
        order: 0,
        collapsed: false
      };

      const DEFAULT_SETTINGS = {
        sortMode: "manual",
        theme: "auto",        // auto | dark | light
        categoryFilter: "all" // all | categoryId
      };

      const Icons = {
        pin: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M14 4h-4v5l-2 2v3h8v-3l-2-2z"></path>
            <path d="M12 14v7"></path>
          </svg>`,
        unpin: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M14 4h-4v5l-2 2v3h8v-3l-2-2z"></path>
            <path d="M12 14v7"></path>
            <path d="M4 4l16 16"></path>
          </svg>`,
        copy: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <rect x="9" y="9" width="10" height="10" rx="2"></rect>
            <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1"></path>
          </svg>`,
        paste: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M9 4h6"></path>
            <path d="M9 4a2 2 0 0 0-2 2v1h10V6a2 2 0 0 0-2-2"></path>
            <path d="M7 7h10v15H7z"></path>
          </svg>`,
        clear: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M20 20H8"></path>
            <path d="M6 14l8-8 4 4-8 8H6z"></path>
            <path d="M14 6l4 4"></path>
          </svg>`,
        trash: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M3 6h18"></path>
            <path d="M8 6V4h8v2"></path>
            <path d="M19 6l-1 16H6L5 6"></path>
            <path d="M10 11v6"></path>
            <path d="M14 11v6"></path>
          </svg>`,
        chevronDown: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M6 9l6 6 6-6"></path>
          </svg>`,
        chevronRight: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M9 6l6 6-6 6"></path>
          </svg>`,
        plus: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M12 5v14"></path>
            <path d="M5 12h14"></path>
          </svg>`
      };

      const $ = (id) => document.getElementById(id);

      const searchEl = $("search");
      const clearSearchEl = $("clearSearch");
      const sortEl = $("sort");
      const catFilterEl = $("catFilter");
      const catBtnEl = $("catBtn");

      const newNoteEl = $("newNote");
      const exportJsonEl = $("exportJson");
      const exportTxtEl = $("exportTxt");
      const importBtnEl = $("importBtn");
      const importFileEl = $("importFile");
      const themeBtnEl = $("themeBtn");
      const countEl = $("count");

      const pinnedSectionEl = $("pinnedSection");
      const pinnedListEl = $("pinnedList");
      const notesListEl = $("notesList");
      const emptyEl = $("empty");
      const toastEl = $("toast");

      const catDialogEl = $("catDialog");
      const catCloseEl = $("catClose");
      const catTableEl = $("catTable");
      const catNewNameEl = $("catNewName");
      const catNewColorEl = $("catNewColor");
      const catAddBtnEl = $("catAddBtn");

      let notes = [];
      let categories = [];
      let settings = { ...DEFAULT_SETTINGS };
      let undoState = null;

      /* Drag state */
      let dragId = null;
      let dragCtx = null; // { id, pinned, categoryId }

      /* ✅ drag táctil */
      let pendingPress = null; // { pointerId, timer, startX, startY, lastX, lastY, noteEl, container }
      let pointerDrag = null;  // { pointerId, noteEl, container, placeholder, offsetX, offsetY }
      const isCoarsePointer = !!(window.matchMedia && window.matchMedia("(pointer: coarse)").matches);
      const supportsPointer = "PointerEvent" in window;

      /* Auto-sync snapshot (para detectar cambios reales en Sheets) */
      let lastSnapshot = "";

      document.addEventListener("DOMContentLoaded", () => { init(); });

      async function init() {
        try {
          if (isLikelyBadApiUrl_(API_URL)) {
            toast("Configura API_URL con tu /exec real (Apps Script Web App)");
            console.error("API_URL inválida:", API_URL);
            return;
          }

          const remote = await apiGetState_();
          notes = Array.isArray(remote?.notes) ? remote.notes : [];
          categories = Array.isArray(remote?.categories) ? remote.categories : [];

          const localSettings = safeParse(localStorage.getItem(SETTINGS_KEY), {}) || {};
          settings = { ...DEFAULT_SETTINGS, ...(remote?.settings || {}), ...localSettings };

          const savedTheme = localStorage.getItem(THEME_KEY);
          if (savedTheme && ["auto","dark","light"].includes(savedTheme)) settings.theme = savedTheme;

          ensureGeneralCategory();
          sanitizeNotesCategoryIds();

          applyTheme(settings.theme);
          sortEl.value = settings.sortMode;

          computeFixedButtonWidth();
          bindEvents();

          renderCategoryFilter();
          renderAll();

          // “Siembra” Sheets si venía vacío: crea "General" en la pestaña Categories
          if ((categories?.length || 0) === 0 && (notes?.length || 0) === 0) {
            saveDebounced();
          }

          lastSnapshot = makeSnapshot_(categories, notes);
          startAutoSync();
        } catch (err) {
          toast("Error cargando datos (revisa API_URL /exec y despliegue)");
          console.error(err);
        }
      }

      function bindEvents() {
        const onSearch = debounce(() => applySearchAndHighlights(), 60);
        searchEl.addEventListener("input", onSearch);

        clearSearchEl.addEventListener("click", () => {
          searchEl.value = "";
          searchEl.focus();
          applySearchAndHighlights();
        });

        sortEl.addEventListener("change", () => {
          settings.sortMode = sortEl.value;
          saveUISettings_();
          renderAll();
          toast("Orden actualizado");
        });

        catFilterEl.addEventListener("change", () => {
          settings.categoryFilter = catFilterEl.value;
          saveUISettings_();
          renderAll();
          toast("Filtro actualizado");
        });

        catBtnEl.addEventListener("click", () => {
          openCatDialog();
        });

        catCloseEl.addEventListener("click", () => closeCatDialog());
        catDialogEl.addEventListener("click", (e) => {
          const rect = catDialogEl.getBoundingClientRect();
          const inDialog = (
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top  && e.clientY <= rect.bottom
          );
          if (!inDialog) closeCatDialog();
        });

        catAddBtnEl.addEventListener("click", () => addCategoryFromForm());
        catNewNameEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") { e.preventDefault(); addCategoryFromForm(); }
        });

        newNoteEl.addEventListener("click", () => {
          const catId = (settings.categoryFilter && settings.categoryFilter !== "all")
            ? settings.categoryFilter
            : GENERAL_CATEGORY_ID;

          const n = createNote({ afterId: null, pinned: false, categoryId: catId });
          notes.push(n);
          if (settings.sortMode === "manual") renormalizeOrders(false, catId);
          saveDebounced();
          renderAll();
          focusNote(n.id);
          toast("Nota creada");
        });

        exportJsonEl.addEventListener("click", exportJSON);
        exportTxtEl.addEventListener("click", exportTXT);

        importBtnEl.addEventListener("click", () => importFileEl.click());
        importFileEl.addEventListener("change", async () => {
          const file = importFileEl.files && importFileEl.files[0];
          importFileEl.value = "";
          if (!file) return;
          await importFile(file);
        });

        themeBtnEl.addEventListener("click", () => {
          settings.theme = nextTheme(settings.theme);
          localStorage.setItem(THEME_KEY, settings.theme);
          applyTheme(settings.theme);
          toast(`Tema: ${themeLabel(settings.theme)}`);
        });

        /* Delegación de eventos (listas dinámicas) */
        [pinnedListEl, notesListEl].forEach(root => {
          root.addEventListener("click", onListClick);
          root.addEventListener("keydown", onListKeydown);
          root.addEventListener("input", onListInput);
          root.addEventListener("change", onListChange);
          root.addEventListener("focusin", onListFocusIn);
          root.addEventListener("focusout", onListFocusOut);

          /* Desktop: drag & drop */
          root.addEventListener("dragstart", onDragStart);
          root.addEventListener("dragover", onDragOver);
          root.addEventListener("drop", onDrop);
          root.addEventListener("dragend", onDragEnd);

          /* Móvil: pointer drag */
          if (supportsPointer) root.addEventListener("pointerdown", onHandlePointerDown);
        });

        // ✅ mejora: intenta guardar también en eventos más confiables en móviles
        window.addEventListener("beforeunload", saveNow);
        window.addEventListener("pagehide", saveNow);
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "hidden") saveNow();
        });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && catDialogEl.open) closeCatDialog();
        });
      }

      function saveUISettings_() {
        try {
          localStorage.setItem(SETTINGS_KEY, JSON.stringify({
            sortMode: settings.sortMode,
            categoryFilter: settings.categoryFilter,
            theme: settings.theme
          }));
        } catch {}
      }

      function safeParse(json, fallback) { try { return JSON.parse(json); } catch { return fallback; } }
      function makeId() { return (window.crypto?.randomUUID) ? crypto.randomUUID() : String(Date.now()) + "_" + Math.random().toString(16).slice(2); }

      function norm(s) {
        return (s ?? "")
          .toString()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .toLowerCase();
      }

      function escapeHTML(s) {
        return (s ?? "").toString().replace(/[&<>"']/g, (ch) => ({
          "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"
        }[ch]));
      }

      function debounce(fn, ms) {
        let t = 0;
        return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
      }

      function buildNormMap(str) {
        let normStr = "";
        const map = [];
        for (let i = 0; i < str.length; i++) {
          const ch = str[i];
          const n = ch.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
          for (let j = 0; j < n.length; j++) {
            normStr += n[j];
            map.push(i);
          }
        }
        return { normStr, map };
      }

      function makeHighlightedHTML(text, terms, preview = false) {
        if (!text) return `<span class="placeholder">Escribe una nota…</span>`;

        const cleanTerms = (terms || []).filter(Boolean);
        const baseText = preview
          ? (text ?? "").toString().replace(/\r/g, "").replace(/\n+/g, " ").replace(/\s+/g, " ").trim()
          : (text ?? "").toString();

        if (!cleanTerms.length) {
          const escaped = escapeHTML(baseText);
          return preview ? escaped : escaped.replace(/\n/g, "<br>");
        }

        const { normStr, map } = buildNormMap(baseText);
        const ranges = [];

        for (const term of cleanTerms) {
          let start = 0;
          while (true) {
            const idx = normStr.indexOf(term, start);
            if (idx === -1) break;
            ranges.push([idx, idx + term.length]);
            start = idx + term.length;
          }
        }

        if (!ranges.length) {
          const escaped = escapeHTML(baseText);
          return preview ? escaped : escaped.replace(/\n/g, "<br>");
        }

        ranges.sort((a, b) => a[0] - b[0] || a[1] - b[1]);

        const merged = [];
        for (const r of ranges) {
          if (!merged.length || r[0] > merged[merged.length - 1][1]) merged.push(r.slice());
          else merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], r[1]);
        }

        const origRanges = merged.map(([a, b]) => {
          const startOrig = map[a] ?? 0;
          const endOrig = (map[b - 1] ?? (baseText.length - 1)) + 1;
          return [startOrig, endOrig];
        });

        origRanges.sort((a, b) => a[0] - b[0]);
        const final = [];
        for (const r of origRanges) {
          if (!final.length || r[0] > final[final.length - 1][1]) final.push(r.slice());
          else final[final.length - 1][1] = Math.max(final[final.length - 1][1], r[1]);
        }

        let out = "";
        let last = 0;
        for (const [s, e] of final) {
          out += escapeHTML(baseText.slice(last, s));
          out += `<mark>${escapeHTML(baseText.slice(s, e))}</mark>`;
          last = e;
        }
        out += escapeHTML(baseText.slice(last));
        return preview ? out : out.replace(/\n/g, "<br>");
      }

      function cssEscape(s) {
        if (window.CSS && typeof CSS.escape === "function") return CSS.escape(s);
        return String(s).replace(/["\\]/g, "\\$&");
      }

      /* =========================
         Categories
      ========================== */
      function ensureGeneralCategory() {
        if (!categories || !Array.isArray(categories)) categories = [];
        const hasGeneral = categories.some(c => String(c.id) === GENERAL_CATEGORY_ID);
        if (!hasGeneral) categories.unshift({ ...DEFAULT_GENERAL_CATEGORY });

        // Normaliza
        categories.forEach((c, i) => {
          if (!c || typeof c !== "object") return;
          c.id = String(c.id ?? makeId());
          c.name = String(c.name ?? "Categoría");
          c.color = String(c.color ?? "#64748B");
          c.order = Number.isFinite(Number(c.order)) ? Number(c.order) : i * 1000;
          c.collapsed = Boolean(c.collapsed ?? false);
        });

        const general = categories.find(c => c.id === GENERAL_CATEGORY_ID);
        if (general) general.order = Math.min(general.order, -100000);
        categories = sortCategories(categories);
      }

      function sortCategories(list) {
        return (list || []).slice().sort((a, b) => {
          const ao = Number(a.order ?? 0), bo = Number(b.order ?? 0);
          if (ao !== bo) return ao - bo;
          return String(a.name || "").localeCompare(String(b.name || ""), "es", { sensitivity: "base" });
        });
      }

      function getCategoryById(id) {
        return categories.find(c => c.id === id) || null;
      }

      function sanitizeNotesCategoryIds() {
        const ids = new Set(categories.map(c => c.id));
        for (const n of notes) {
          if (!n.categoryId || !ids.has(n.categoryId)) n.categoryId = GENERAL_CATEGORY_ID;
        }
      }

      function renderCategoryFilter() {
        const current = settings.categoryFilter || "all";
        catFilterEl.innerHTML = "";

        const optAll = document.createElement("option");
        optAll.value = "all";
        optAll.textContent = "Todas";
        catFilterEl.appendChild(optAll);

        const sorted = sortCategories(categories);
        for (const c of sorted) {
          const opt = document.createElement("option");
          opt.value = c.id;
          opt.textContent = c.name;
          catFilterEl.appendChild(opt);
        }

        if (current !== "all" && !getCategoryById(current)) settings.categoryFilter = "all";
        catFilterEl.value = settings.categoryFilter || "all";
      }

      function openCatDialog() {
        renderCatManager();
        if (typeof catDialogEl.showModal === "function") catDialogEl.showModal();
        else catDialogEl.setAttribute("open", "open");
        catNewNameEl.focus();
      }

      function closeCatDialog() {
        if (typeof catDialogEl.close === "function") catDialogEl.close();
        else catDialogEl.removeAttribute("open");
      }

      function renderCatManager() {
        ensureGeneralCategory();
        categories = sortCategories(categories);
        catTableEl.innerHTML = "";

        for (let i = 0; i < categories.length; i++) {
          const c = categories[i];
          const row = document.createElement("div");
          row.className = "cat-row";
          row.dataset.catId = c.id;

          const name = document.createElement("input");
          name.type = "text";
          name.value = c.name;
          name.placeholder = "Nombre";
          name.setAttribute("aria-label", "Nombre de categoría");
          name.disabled = (c.id === GENERAL_CATEGORY_ID);

          const color = document.createElement("input");
          color.type = "color";
          color.value = normalizeColor(c.color) || "#64748B";
          color.setAttribute("aria-label", "Color de categoría");

          const up = document.createElement("button");
          up.className = "mini-btn";
          up.type = "button";
          up.innerHTML = "↑";
          up.title = "Subir";
          up.setAttribute("aria-label", "Subir");
          up.disabled = (i === 0);

          const down = document.createElement("button");
          down.className = "mini-btn";
          down.type = "button";
          down.innerHTML = "↓";
          down.title = "Bajar";
          down.setAttribute("aria-label", "Bajar");
          down.disabled = (i === categories.length - 1);

          const del = document.createElement("button");
          del.className = "btn btn-danger";
          del.type = "button";
          del.title = "Eliminar";
          del.setAttribute("aria-label", "Eliminar");
          del.innerHTML = `${Icons.trash}<span class="sr-only">Eliminar</span>`;
          del.disabled = (c.id === GENERAL_CATEGORY_ID);

          name.addEventListener("input", () => {
            c.name = name.value.trim() || c.name;
            saveDebounced();
            renderCategoryFilter();
            renderAllDebounced();
          });

          color.addEventListener("input", () => {
            c.color = color.value;
            saveDebounced();
            renderAllDebounced();
          });

          up.addEventListener("click", () => {
            swapCategoryOrder(i, i - 1);
            toast("Categoría movida");
          });

          down.addEventListener("click", () => {
            swapCategoryOrder(i, i + 1);
            toast("Categoría movida");
          });

          del.addEventListener("click", () => {
            if (!confirm(`¿Eliminar la categoría "${c.name}"?\nLas notas pasarán a "General".`)) return;
            deleteCategory(c.id);
          });

          row.appendChild(name);
          row.appendChild(color);
          row.appendChild(up);
          row.appendChild(down);
          row.appendChild(del);

          catTableEl.appendChild(row);
        }
      }

      const renderAllDebounced = debounce(() => renderAll(), 120);

      function normalizeColor(col) {
        const s = String(col || "").trim();
        if (!s) return "";
        if (/^#[0-9a-fA-F]{6}$/.test(s)) return s;
        if (/^#[0-9a-fA-F]{3}$/.test(s)) {
          return "#" + s.slice(1).split("").map(x => x + x).join("");
        }
        return s;
      }

      function swapCategoryOrder(i, j) {
        categories = sortCategories(categories);
        if (j < 0 || j >= categories.length) return;
        const a = categories[i], b = categories[j];
        const tmp = a.order;
        a.order = b.order;
        b.order = tmp;

        renormalizeCategoryOrders();
        categories = sortCategories(categories);
        saveDebounced();
        renderCategoryFilter();
        renderCatManager();
        renderAll();
      }

      function renormalizeCategoryOrders() {
        categories = sortCategories(categories);
        for (let i = 0; i < categories.length; i++) {
          categories[i].order = i * 1000;
        }
        const general = categories.find(c => c.id === GENERAL_CATEGORY_ID);
        if (general) general.order = -100000;
      }

      function deleteCategory(catId) {
        if (catId === GENERAL_CATEGORY_ID) return;

        for (const n of notes) {
          if (n.categoryId === catId) {
            n.categoryId = GENERAL_CATEGORY_ID;
            if (settings.sortMode === "manual") {
              n.order = lastOrder(n.pinned, GENERAL_CATEGORY_ID) + 1000;
            }
            n.updatedAt = Date.now();
          }
        }

        categories = categories.filter(c => c.id !== catId);
        ensureGeneralCategory();

        if (settings.sortMode === "manual") {
          renormalizeOrders(true, GENERAL_CATEGORY_ID);
          renormalizeOrders(false, GENERAL_CATEGORY_ID);
        }

        if (settings.categoryFilter === catId) settings.categoryFilter = "all";

        saveDebounced();
        renderCategoryFilter();
        renderCatManager();
        renderAll();
        toast("Categoría eliminada");
      }

      function addCategoryFromForm() {
        const name = (catNewNameEl.value || "").trim();
        const color = normalizeColor(catNewColorEl.value) || "#64748B";

        if (!name) { toast("Escribe un nombre"); catNewNameEl.focus(); return; }

        const exists = categories.find(c => norm(c.name) === norm(name));
        if (exists) {
          toast("Ya existe una categoría con ese nombre");
          catNewNameEl.select();
          return;
        }

        const maxOrder = categories.reduce((m, c) => Math.max(m, Number(c.order ?? 0)), 0);
        const c = { id: makeId(), name, color, order: maxOrder + 1000, collapsed: false };
        categories.push(c);
        ensureGeneralCategory();

        catNewNameEl.value = "";
        catNewColorEl.value = "#64748B";

        saveDebounced();
        renderCategoryFilter();
        renderCatManager();
        renderAll();
        toast("Categoría creada");
      }

      /* =========================
         Serialize + Save (Sheets)
      ========================== */
      function serializeState() {
        return {
          v: 3,
          savedAt: Date.now(),
          notes,
          categories,
          settings: {
            sortMode: settings.sortMode,
            theme: settings.theme,
            categoryFilter: settings.categoryFilter
          }
        };
      }

      const saveDebounced = debounce(() => {
        lastSnapshot = makeSnapshot_(categories, notes);

        apiSaveAll_(serializeState())
          .catch(() => toast("No pude guardar (revisa API_URL /exec y deploy)"));
      }, 600);

      function saveNow() {
        try {
          lastSnapshot = makeSnapshot_(categories, notes);
          apiSaveAllFireAndForget_(serializeState());
        } catch {}
      }

      function makeSnapshot_(cats, nts) {
        try {
          return JSON.stringify({
            categories: Array.isArray(cats) ? cats : [],
            notes: Array.isArray(nts) ? nts : []
          });
        } catch {
          return String(Date.now());
        }
      }

      function startAutoSync() {
        setInterval(async () => {
          if (document.querySelector(".note.editing")) return;

          try {
            const remote = await apiGetState_();
            const snap = makeSnapshot_(remote?.categories, remote?.notes);
            if (snap !== lastSnapshot) {
              notes = Array.isArray(remote?.notes) ? remote.notes : [];
              categories = Array.isArray(remote?.categories) ? remote.categories : [];

              ensureGeneralCategory();
              sanitizeNotesCategoryIds();

              renderCategoryFilter();
              renderAll();

              lastSnapshot = snap;
            }
          } catch {}
        }, AUTOSYNC_MS);
      }

      /* =========================
         Theme + Helpers
      ========================== */
      function applyTheme(theme) {
        let t = theme;
        if (theme === "auto") {
          t = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches ? "light" : "dark";
        }
        document.documentElement.setAttribute("data-theme", t);
      }

      function nextTheme(theme) { return theme === "auto" ? "dark" : theme === "dark" ? "light" : "auto"; }
      function themeLabel(theme) { return theme === "auto" ? "Auto" : theme === "dark" ? "Oscuro" : theme === "light" ? "Claro" : "Auto"; }

      function computeFixedButtonWidth() {
        document.documentElement.style.setProperty("--btn-fixed-width", "44px");
      }

      function lastOrder(pinned, categoryId) {
        const group = notes
          .filter(n => !!n.pinned === !!pinned && (n.categoryId || GENERAL_CATEGORY_ID) === categoryId)
          .slice()
          .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
        return group.length ? (group[group.length - 1].order ?? 0) : -1000;
      }

      function createNote({ afterId = null, pinned = false, categoryId = GENERAL_CATEGORY_ID }) {
        const now = Date.now();

        const group = notes
          .filter(n => !!n.pinned === !!pinned && (n.categoryId || GENERAL_CATEGORY_ID) === categoryId)
          .slice()
          .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

        let order = group.length ? (group[group.length - 1].order ?? 0) + 1000 : 0;

        if (afterId) {
          const idx = group.findIndex(n => n.id === afterId);
          if (idx !== -1) {
            const after = group[idx];
            const next = group[idx + 1];
            order = next ? (Number(after.order ?? 0) + Number(next.order ?? 0)) / 2 : Number(after.order ?? 0) + 1000;
          }
        }

        return {
          id: makeId(),
          text: "",
          createdAt: now,
          updatedAt: now,
          pinned: !!pinned,
          order,
          categoryId
        };
      }

      function renormalizeOrders(pinned, categoryId) {
        const group = notes
          .filter(n => !!n.pinned === !!pinned && (n.categoryId || GENERAL_CATEGORY_ID) === categoryId)
          .slice()
          .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

        for (let i = 0; i < group.length; i++) group[i].order = i * 1000;
      }

      function getNoteById(id) { return notes.find(n => n.id === id) || null; }

      function getSorter() {
        const mode = settings.sortMode;
        const sorters = {
          manual: (a, b) => (a.order ?? 0) - (b.order ?? 0),
          updated_desc: (a, b) => (b.updatedAt ?? 0) - (a.updatedAt ?? 0),
          created_desc: (a, b) => (b.createdAt ?? 0) - (a.createdAt ?? 0),
          alpha_asc: (a, b) => (a.text || "").localeCompare((b.text || ""), "es", { sensitivity: "base" })
        };
        return sorters[mode] || sorters.manual;
      }

      function groupNotesByCategory(list) {
        const map = new Map();
        for (const n of list) {
          const catId = n.categoryId || GENERAL_CATEGORY_ID;
          if (!map.has(catId)) map.set(catId, []);
          map.get(catId).push(n);
        }
        return map;
      }

      function getSortedNotesByCategory() {
        const sorter = getSorter();
        const pinned = notes.filter(n => !!n.pinned);
        const normal = notes.filter(n => !n.pinned);

        const pinnedByCat = groupNotesByCategory(pinned);
        const normalByCat = groupNotesByCategory(normal);

        for (const [k, arr] of pinnedByCat) pinnedByCat.set(k, arr.slice().sort(sorter));
        for (const [k, arr] of normalByCat) normalByCat.set(k, arr.slice().sort(sorter));

        return { pinnedByCat, normalByCat };
      }

      function currentTerms() {
        return norm(searchEl.value).split(/\s+/).filter(Boolean);
      }

      function pinHTML(pinned) {
        const label = pinned ? "Soltar" : "Fijar";
        const icon = pinned ? Icons.unpin : Icons.pin;
        return `${icon}<span class="sr-only">${label}</span>`;
      }

      function categoryBadgeHTML(catId) {
        const c = getCategoryById(catId) || DEFAULT_GENERAL_CATEGORY;
        const col = normalizeColor(c.color) || "#64748B";
        return `<span class="badge" title="Categoría">
          <span class="dot" style="background:${escapeHTML(col)}"></span>
          📁 ${escapeHTML(c.name)}
        </span>`;
      }

      function pinnedBadgeHTML(pinned) {
        return pinned ? `<span class="badge" title="Fijada">📌 Fijada</span>` : "";
      }

      function buildCategorySelect(note) {
        const sel = document.createElement("select");
        sel.className = "cat-select";
        sel.dataset.role = "catSelect";
        sel.setAttribute("aria-label", "Cambiar categoría");

        const sorted = sortCategories(categories);
        for (const c of sorted) {
          const opt = document.createElement("option");
          opt.value = c.id;
          opt.textContent = c.name;
          sel.appendChild(opt);
        }
        sel.value = note.categoryId || GENERAL_CATEGORY_ID;
        return sel;
      }

      function buildNoteEl(note) {
        const el = document.createElement("article");
        el.className = "note";
        el.dataset.id = note.id;
        el.dataset.norm = norm(note.text);
        el.dataset.categoryId = note.categoryId || GENERAL_CATEGORY_ID;
        el.dataset.pinned = String(!!note.pinned);
        el.draggable = false;

        const drag = document.createElement("button");
        drag.className = "drag-handle";
        drag.type = "button";
        drag.title = "Arrastrar para reordenar (modo manual). En móvil: mantén presionado y arrastra.";
        drag.setAttribute("aria-label", "Arrastrar para reordenar");
        drag.textContent = "≡";
        drag.draggable = true;

        const content = document.createElement("div");
        content.className = "content";

        const view = document.createElement("div");
        view.className = "note-view";
        view.tabIndex = 0;
        view.setAttribute("role", "button");
        view.setAttribute("aria-label", "Editar nota (Enter o clic)");
        view.innerHTML = makeHighlightedHTML(note.text, currentTerms(), true);

        const edit = document.createElement("textarea");
        edit.className = "note-edit";
        edit.value = note.text;
        edit.rows = 1;
        edit.spellcheck = false;
        edit.placeholder = "Escribe aquí…";
        edit.setAttribute("aria-label", "Editor de nota");

        const meta = document.createElement("div");
        meta.className = "meta";

        const catSel = buildCategorySelect(note);

        const wrapBadges = document.createElement("div");
        wrapBadges.style.display = "flex";
        wrapBadges.style.gap = "8px";
        wrapBadges.style.flexWrap = "wrap";
        wrapBadges.style.alignItems = "center";
        wrapBadges.innerHTML = `${categoryBadgeHTML(note.categoryId)}${pinnedBadgeHTML(note.pinned)}`;

        meta.appendChild(wrapBadges);
        meta.appendChild(catSel);

        content.appendChild(view);
        content.appendChild(edit);
        content.appendChild(meta);

        const actions = document.createElement("div");
        actions.className = "actions";

        const pinBtn = document.createElement("button");
        pinBtn.className = "btn btn-ghost";
        pinBtn.type = "button";
        pinBtn.dataset.action = "pin";
        pinBtn.title = note.pinned ? "Soltar" : "Fijar";
        pinBtn.setAttribute("aria-label", note.pinned ? "Soltar" : "Fijar");
        pinBtn.innerHTML = pinHTML(note.pinned);

        const cpBtn = document.createElement("button");
        cpBtn.className = "btn";
        cpBtn.type = "button";
        cpBtn.dataset.action = "copyPaste";
        setCopyPasteUI(cpBtn, note.text);

        const clearBtn = document.createElement("button");
        clearBtn.className = "btn btn-ghost";
        clearBtn.type = "button";
        clearBtn.dataset.action = "clear";
        clearBtn.title = "Limpiar";
        clearBtn.setAttribute("aria-label", "Limpiar");
        clearBtn.innerHTML = `${Icons.clear}<span class="sr-only">Limpiar</span>`;

        const delBtn = document.createElement("button");
        delBtn.className = "btn btn-danger";
        delBtn.type = "button";
        delBtn.dataset.action = "delete";
        delBtn.title = "Eliminar";
        delBtn.setAttribute("aria-label", "Eliminar");
        delBtn.innerHTML = `${Icons.trash}<span class="sr-only">Eliminar</span>`;

        actions.appendChild(pinBtn);
        actions.appendChild(cpBtn);
        actions.appendChild(clearBtn);
        actions.appendChild(delBtn);

        el.appendChild(drag);
        el.appendChild(content);
        el.appendChild(actions);

        return el;
      }

      function buildCatGroupEl({ cat, pinned, notesInCat, showEmpty }) {
        const group = document.createElement("div");
        group.className = "cat-group" + (cat.collapsed ? " collapsed" : "");
        group.dataset.catId = cat.id;
        group.dataset.pinned = String(!!pinned);

        const head = document.createElement("div");
        head.className = "cat-head";

        const left = document.createElement("div");
        left.className = "cat-left";

        const toggle = document.createElement("button");
        toggle.className = "cat-toggle";
        toggle.type = "button";
        toggle.dataset.action = "toggleCat";
        toggle.dataset.catId = cat.id;
        toggle.dataset.pinned = String(!!pinned);
        toggle.title = "Contraer/Expandir";
        toggle.setAttribute("aria-label", "Contraer/Expandir");
        toggle.setAttribute("aria-expanded", String(!cat.collapsed));
        toggle.innerHTML = cat.collapsed ? Icons.chevronRight : Icons.chevronDown;

        const pill = document.createElement("span");
        pill.className = "cat-pill";
        pill.title = "Categoría";
        pill.innerHTML = `<span class="cat-dot" style="background:${escapeHTML(normalizeColor(cat.color) || "#64748B")}"></span>
                          <span class="cat-name">${escapeHTML(cat.name)}</span>
                          <span class="cat-count" data-role="catCount">${notesInCat.length}</span>`;

        left.appendChild(toggle);
        left.appendChild(pill);

        const right = document.createElement("div");
        right.className = "cat-right";

        if (!pinned) {
          const add = document.createElement("button");
          add.className = "btn btn-ghost";
          add.type = "button";
          add.dataset.action = "newInCat";
          add.dataset.catId = cat.id;
          add.title = "Nueva nota en esta categoría";
          add.setAttribute("aria-label", "Nueva nota en esta categoría");
          add.innerHTML = `${Icons.plus}<span class="sr-only">Nueva</span>`;
          right.appendChild(add);
        }

        head.appendChild(left);
        head.appendChild(right);

        const list = document.createElement("div");
        list.className = "cat-list";
        list.setAttribute("role", "list");
        list.dataset.role = "catList";
        list.dataset.categoryId = cat.id;
        list.dataset.pinned = String(!!pinned);

        if (notesInCat.length) {
          const frag = document.createDocumentFragment();
          for (const n of notesInCat) frag.appendChild(buildNoteEl(n));
          list.appendChild(frag);
        } else if (showEmpty) {
          const empty = document.createElement("div");
          empty.className = "cat-empty";
          empty.textContent = "Sin notas en esta categoría";
          list.appendChild(empty);
        }

        group.appendChild(head);
        group.appendChild(list);
        return group;
      }

      function renderAll() {
        ensureGeneralCategory();
        renderCategoryFilter();

        const { pinnedByCat, normalByCat } = getSortedNotesByCategory();
        const sortedCats = sortCategories(categories);

        const filter = settings.categoryFilter || "all";
        const terms = currentTerms();
        const isSearching = terms.length > 0;

        pinnedListEl.innerHTML = "";
        notesListEl.innerHTML = "";

        let pinnedHasAnything = false;
        for (const cat of sortedCats) {
          if (filter !== "all" && cat.id !== filter) continue;
          const list = pinnedByCat.get(cat.id) || [];
          if (!list.length) continue;

          pinnedHasAnything = true;
          pinnedListEl.appendChild(buildCatGroupEl({
            cat,
            pinned: true,
            notesInCat: list,
            showEmpty: false
          }));
        }
        pinnedSectionEl.hidden = !pinnedHasAnything;

        for (const cat of sortedCats) {
          if (filter !== "all" && cat.id !== filter) continue;

          const list = normalByCat.get(cat.id) || [];
          const showEmpty = (!isSearching);

          notesListEl.appendChild(buildCatGroupEl({
            cat,
            pinned: false,
            notesInCat: list,
            showEmpty
          }));
        }

        applySearchAndHighlights();
      }

      function applySearchAndHighlights() {
        const terms = currentTerms();
        const filter = settings.categoryFilter || "all";
        const isSearching = terms.length > 0;

        const total = (filter === "all")
          ? notes.length
          : notes.filter(n => (n.categoryId || GENERAL_CATEGORY_ID) === filter).length;

        let visible = 0;

        const roots = [pinnedListEl, notesListEl];
        for (const root of roots) {
          const items = root.querySelectorAll(".note");
          items.forEach(el => {
            const id = el.dataset.id;
            const note = getNoteById(id);
            if (!note) return;

            const t = el.dataset.norm || "";
            const matchText = terms.every(term => t.includes(term));

            const catId = note.categoryId || GENERAL_CATEGORY_ID;
            const matchCat = (filter === "all") ? true : (catId === filter);

            const match = matchText && matchCat;
            el.hidden = !match;
            if (match) visible++;

            const view = el.querySelector(".note-view");
            if (view) view.innerHTML = makeHighlightedHTML(note.text, terms, true);

            const cpBtn = el.querySelector('[data-action="copyPaste"]');
            if (cpBtn) setCopyPasteUI(cpBtn, note.text);

            const pinBtn = el.querySelector('[data-action="pin"]');
            if (pinBtn) {
              pinBtn.innerHTML = pinHTML(note.pinned);
              pinBtn.title = note.pinned ? "Soltar" : "Fijar";
              pinBtn.setAttribute("aria-label", note.pinned ? "Soltar" : "Fijar");
            }

            const meta = el.querySelector(".meta");
            if (meta) {
              const badgeWrap = meta.firstElementChild;
              const sel = meta.querySelector('select[data-role="catSelect"]');

              if (badgeWrap) {
                badgeWrap.innerHTML = `${categoryBadgeHTML(catId)}${pinnedBadgeHTML(note.pinned)}`;
              }
              if (sel) sel.value = catId;
            }

            el.dataset.categoryId = catId;
            el.dataset.pinned = String(!!note.pinned);
          });
        }

        for (const root of roots) {
          const groups = root.querySelectorAll(".cat-group");
          groups.forEach(group => {
            const list = group.querySelector(".cat-list");
            const countEl2 = group.querySelector('[data-role="catCount"]');

            const visibleNotes = list ? list.querySelectorAll(".note:not([hidden])").length : 0;
            if (countEl2) countEl2.textContent = String(visibleNotes);

            if (isSearching) group.classList.remove("collapsed");

            if (isSearching) {
              group.hidden = (visibleNotes === 0);
            } else {
              group.hidden = false;
            }
          });
        }

        const anyPinnedVisible = pinnedListEl.querySelector(".note:not([hidden])");
        pinnedSectionEl.hidden = !anyPinnedVisible;

        const anyNormalVisible = notesListEl.querySelector(".note:not([hidden])");
        emptyEl.hidden = (anyPinnedVisible || anyNormalVisible);

        updateCount(visible, total);

        const dragEnabled = (settings.sortMode === "manual");
        document.querySelectorAll(".drag-handle").forEach(b => {
          b.style.opacity = dragEnabled ? "1" : ".35";
          b.title = dragEnabled
            ? "Arrastrar para reordenar (modo manual). En móvil: mantén presionado y arrastra."
            : "Reordenar solo disponible en modo Manual";

          b.draggable = dragEnabled && !isCoarsePointer;
        });
      }

      function updateCount(visible, total) {
        countEl.textContent = `${visible} de ${total}`;
      }

      /* =========================
         List events
      ========================== */
      function findNoteEl(target) { return target.closest(".note"); }

      function onListClick(e) {
        const catBtn = e.target.closest("[data-action]");
        if (catBtn && catBtn.dataset.action === "toggleCat") {
          const catId = catBtn.dataset.catId;
          const c = getCategoryById(catId);
          if (!c) return;

          c.collapsed = !c.collapsed;
          saveDebounced();

          const group = catBtn.closest(".cat-group");
          if (group) {
            group.classList.toggle("collapsed", c.collapsed);
            catBtn.innerHTML = c.collapsed ? Icons.chevronRight : Icons.chevronDown;
            catBtn.setAttribute("aria-expanded", String(!c.collapsed));
          }
          return;
        }

        if (catBtn && catBtn.dataset.action === "newInCat") {
          const catId = catBtn.dataset.catId || GENERAL_CATEGORY_ID;
          const n = createNote({ afterId: null, pinned: false, categoryId: catId });
          notes.push(n);
          if (settings.sortMode === "manual") renormalizeOrders(false, catId);
          saveDebounced();
          renderAll();
          focusNote(n.id);
          toast("Nota creada");
          return;
        }

        const noteEl = findNoteEl(e.target);
        if (!noteEl) return;

        const id = noteEl.dataset.id;
        const note = getNoteById(id);
        if (!note) return;

        if (e.target.closest(".note-view")) {
          enterEdit(noteEl);
          return;
        }

        const actionBtn = e.target.closest("[data-action]");
        if (!actionBtn) return;

        const action = actionBtn.dataset.action;

        if (action === "pin") {
          const prevPinned = !!note.pinned;
          note.pinned = !note.pinned;
          note.updatedAt = Date.now();

          if (settings.sortMode === "manual") {
            const catId = note.categoryId || GENERAL_CATEGORY_ID;
            note.order = lastOrder(note.pinned, catId) + 1000;
            renormalizeOrders(prevPinned, catId);
            renormalizeOrders(note.pinned, catId);
          }

          saveDebounced();
          renderAll();
          toast(note.pinned ? "Nota fijada 📌" : "Nota liberada");
          return;
        }

        if (action === "copyPaste") {
          (async () => {
            if (note.text && note.text.length > 0) {
              const ok = await copyToClipboard(note.text);
              toast(ok ? "Copiado ✅" : "No pude copiar ❌");
            } else {
              const clip = await readFromClipboard();
              note.text = clip;
              note.updatedAt = Date.now();
              saveDebounced();

              noteEl.dataset.norm = norm(note.text);
              const edit = noteEl.querySelector(".note-edit");
              if (edit) edit.value = note.text;
              applySearchAndHighlights();
              toast("Pegado ✅");
            }
          })();
          return;
        }

        if (action === "clear") {
          note.text = "";
          note.updatedAt = Date.now();
          saveDebounced();

          noteEl.dataset.norm = "";
          const edit = noteEl.querySelector(".note-edit");
          if (edit) edit.value = "";
          applySearchAndHighlights();
          toast("Nota limpiada");
          return;
        }

        if (action === "delete") {
          deleteNote(note.id);
          return;
        }
      }

      function onListKeydown(e) {
        const noteEl = findNoteEl(e.target);
        if (!noteEl) return;

        if (e.target.classList.contains("note-view") && e.key === "Enter") {
          e.preventDefault();
          enterEdit(noteEl);
          return;
        }

        if (e.target.classList.contains("note-edit")) {
          if (e.key === "Escape") {
            e.preventDefault();
            e.target.blur();
            return;
          }

          if (e.ctrlKey && e.key === "Enter") {
            e.preventDefault();
            return;
          }
        }
      }

      function onListInput(e) {
        if (!e.target.classList.contains("note-edit")) return;

        const noteEl = findNoteEl(e.target);
        if (!noteEl) return;

        const id = noteEl.dataset.id;
        const note = getNoteById(id);
        if (!note) return;

        note.text = e.target.value;
        note.updatedAt = Date.now();
        noteEl.dataset.norm = norm(note.text);

        maybeAssignCategoryFromPrefix(note);

        autoResize(e.target);

        saveDebounced();
        applySearchAndHighlights();
      }

      function onListChange(e) {
        const sel = e.target.closest('select[data-role="catSelect"]');
        if (!sel) return;

        const noteEl = findNoteEl(sel);
        if (!noteEl) return;

        const id = noteEl.dataset.id;
        const note = getNoteById(id);
        if (!note) return;

        const oldCat = note.categoryId || GENERAL_CATEGORY_ID;
        const newCat = sel.value || GENERAL_CATEGORY_ID;
        if (newCat === oldCat) return;

        note.categoryId = newCat;
        note.updatedAt = Date.now();

        if (settings.sortMode === "manual") {
          note.order = lastOrder(note.pinned, newCat) + 1000;
          renormalizeOrders(note.pinned, oldCat);
          renormalizeOrders(note.pinned, newCat);
        }

        saveDebounced();
        renderAll();
        toast("Categoría cambiada");
      }

      function maybeAssignCategoryFromPrefix(note) {
        const txt = String(note.text || "");
        const m = txt.match(/^\s*@([^\s\r\n\t]+)\s+/);
        if (!m) return;

        const token = m[1];
        const found = categories.find(c => norm(c.name) === norm(token));
        if (!found) return;

        const oldCat = note.categoryId || GENERAL_CATEGORY_ID;
        const newCat = found.id;

        if (newCat !== oldCat) {
          note.categoryId = newCat;
          if (settings.sortMode === "manual") {
            note.order = lastOrder(note.pinned, newCat) + 1000;
            renormalizeOrders(note.pinned, oldCat);
            renormalizeOrders(note.pinned, newCat);
          }
        }

        note.text = txt.replace(/^\s*@([^\s\r\n\t]+)\s+/, "");
      }

      function onListFocusIn(e) {
        if (!e.target.classList.contains("note-edit")) return;
        autoResize(e.target);
      }

      function onListFocusOut(e) {
        if (!e.target.classList.contains("note-edit")) return;

        const noteEl = findNoteEl(e.target);
        if (!noteEl) return;

        exitEdit(noteEl);

        if (settings.sortMode !== "manual") renderAll();
        else applySearchAndHighlights();
      }

      function enterEdit(noteEl) {
        noteEl.classList.add("editing");
        const ta = noteEl.querySelector(".note-edit");
        if (ta) {
          ta.focus();
          ta.selectionStart = ta.selectionEnd = ta.value.length;
          autoResize(ta);
        }
      }

      function exitEdit(noteEl) {
        noteEl.classList.remove("editing");
      }

      function focusNote(id) {
        const safeId = cssEscape(id);
        const noteEl = document.querySelector(`.note[data-id="${safeId}"]`);
        if (!noteEl) return;
        enterEdit(noteEl);
        noteEl.scrollIntoView({ block: "nearest", behavior: "smooth" });
      }

      function autoResize(ta) {
        ta.style.height = "auto";
        ta.style.height = (ta.scrollHeight) + "px";
      }

      async function copyToClipboard(text) {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch {
          try {
            const ta = document.createElement("textarea");
            ta.value = text;
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            document.body.appendChild(ta);
            ta.select();
            const ok = document.execCommand("copy");
            document.body.removeChild(ta);
            return ok;
          } catch {
            return false;
          }
        }
      }

      async function readFromClipboard() {
        try {
          return await navigator.clipboard.readText();
        } catch {
          return prompt("No pude leer el portapapeles automáticamente. Pega aquí el texto:") ?? "";
        }
      }

      function setCopyPasteUI(btn, text) {
        const hasText = (text ?? "").length > 0;
        btn.classList.remove("btn-copy", "btn-paste");

        if (hasText) {
          btn.classList.add("btn-copy");
          btn.title = "Copiar";
          btn.setAttribute("aria-label", "Copiar");
          btn.innerHTML = `${Icons.copy}<span class="sr-only">Copiar</span>`;
        } else {
          btn.classList.add("btn-paste");
          btn.title = "Pegar";
          btn.setAttribute("aria-label", "Pegar");
          btn.innerHTML = `${Icons.paste}<span class="sr-only">Pegar</span>`;
        }
      }

      function deleteNote(id) {
        const idx = notes.findIndex(n => n.id === id);
        if (idx === -1) return;

        const [removed] = notes.splice(idx, 1);
        undoState = { note: removed, index: idx };

        saveDebounced();
        renderAll();

        toastWithAction("Nota eliminada", "Deshacer", () => {
          if (!undoState) return;
          notes.splice(undoState.index, 0, undoState.note);

          if (settings.sortMode === "manual") {
            const catId = undoState.note.categoryId || GENERAL_CATEGORY_ID;
            renormalizeOrders(!!undoState.note.pinned, catId);
          }

          saveDebounced();
          renderAll();
          undoState = null;
          toast("Restaurada ✅");
        }, 4500);
      }

      /* =========================
         Export / Import
      ========================== */
      function exportJSON() {
        const payload = {
          v: 3,
          exportedAt: Date.now(),
          notes,
          categories,
          settings: {
            sortMode: settings.sortMode,
            theme: settings.theme,
            categoryFilter: settings.categoryFilter
          }
        };
        downloadFile("notas.json", JSON.stringify(payload, null, 2), "application/json");
        toast("Exportado JSON ✅");
      }

      function exportTXT() {
        const sortedCats = sortCategories(categories);
        const { pinnedByCat, normalByCat } = getSortedNotesByCategory();

        const blocks = [];

        blocks.push("=== FIJADAS ===");
        for (const cat of sortedCats) {
          const arr = pinnedByCat.get(cat.id) || [];
          if (!arr.length) continue;

          blocks.push(`=== CATEGORIA: ${cat.name} ===`);
          blocks.push(arr.map(n => n.text || "").join("\n\n---\n\n"));
          blocks.push("");
        }

        blocks.push("=== NOTAS ===");
        for (const cat of sortedCats) {
          const arr = normalByCat.get(cat.id) || [];
          if (!arr.length) continue;

          blocks.push(`=== CATEGORIA: ${cat.name} ===`);
          blocks.push(arr.map(n => n.text || "").join("\n\n---\n\n"));
          blocks.push("");
        }

        downloadFile("notas.txt", blocks.join("\n"), "text/plain;charset=utf-8");
        toast("Exportado TXT ✅");
      }

      async function importFile(file) {
        const name = (file.name || "").toLowerCase();
        const text = await file.text();

        if (name.endsWith(".json")) {
          const data = safeParse(text, null);
          if (!data) { toast("JSON inválido ❌"); return; }

          const incomingCats = Array.isArray(data.categories) ? data.categories : [];
          const incomingNotes = Array.isArray(data.notes) ? data.notes : [];

          // Merge simple por nombre normalizado
          ensureGeneralCategory();
          const byNormName = new Map(categories.map(c => [norm(c.name), c]));
          const idMap = new Map();

          for (const ic of incomingCats) {
            if (!ic || !ic.name) continue;
            const k = norm(ic.name);
            if (byNormName.has(k)) {
              idMap.set(String(ic.id), byNormName.get(k).id);
              continue;
            }
            const newId = makeId();
            categories.push({
              id: newId,
              name: String(ic.name),
              color: normalizeColor(ic.color) || "#64748B",
              order: categories.reduce((m, c) => Math.max(m, Number(c.order ?? 0)), 0) + 1000,
              collapsed: !!ic.collapsed
            });
            byNormName.set(k, categories[categories.length - 1]);
            idMap.set(String(ic.id), newId);
          }

          ensureGeneralCategory();
          categories = sortCategories(categories);

          const catIds = new Set(categories.map(c => c.id));
          const existing = new Set(notes.map(n => n.id));

          for (const n of incomingNotes) {
            const nn = { ...n };
            if (!nn.id || existing.has(nn.id)) nn.id = makeId();
            existing.add(nn.id);

            if (idMap.has(String(nn.categoryId))) nn.categoryId = idMap.get(String(nn.categoryId));
            if (!catIds.has(nn.categoryId)) nn.categoryId = GENERAL_CATEGORY_ID;

            const now = Date.now();
            nn.createdAt = Number(nn.createdAt || now);
            nn.updatedAt = Number(nn.updatedAt || nn.createdAt);
            nn.pinned = !!nn.pinned;
            nn.order = Number.isFinite(Number(nn.order)) ? Number(nn.order) : (notes.length * 1000);

            notes.push(nn);
          }

          if (settings.sortMode === "manual") {
            for (const catId of catIds) {
              renormalizeOrders(true, catId);
              renormalizeOrders(false, catId);
            }
          }

          saveDebounced();
          renderCategoryFilter();
          renderAll();
          toast(`Importadas ${incomingNotes.length} notas ✅`);
          return;
        }

        // TXT -> General
        const cleaned = text
          .replace(/\r/g, "")
          .replace(/^===\s*FIJADAS\s*===\s*\n?/im, "")
          .replace(/^===\s*NOTAS\s*===\s*\n?/im, "")
          .replace(/^===\s*CATEGORIA:\s*.*?===\s*\n?/gim, "")
          .split(/\n\s*---\s*\n/g)
          .join("\n\n");

        const blocks = cleaned
          .split(/\n\s*\n+/)
          .map(s => s.trim())
          .filter(Boolean);

        if (!blocks.length) { toast("TXT vacío"); return; }

        const now = Date.now();
        const created = blocks.map((b, i) => ({
          id: makeId(),
          text: b,
          createdAt: now,
          updatedAt: now,
          pinned: false,
          categoryId: GENERAL_CATEGORY_ID,
          order: i * 1000
        }));

        notes.push(...created);
        if (settings.sortMode === "manual") renormalizeOrders(false, GENERAL_CATEGORY_ID);

        saveDebounced();
        renderAll();
        toast(`Importadas ${created.length} notas ✅`);
      }

      function downloadFile(filename, content, mime) {
        const blob = new Blob([content], { type: mime });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      /* =========================
         Toast
      ========================== */
      function toast(message, ms = 1400) {
        toastEl.textContent = message;
        toastEl.classList.add("show");
        clearTimeout(toast._t);
        toast._t = setTimeout(() => toastEl.classList.remove("show"), ms);
      }

      function toastWithAction(message, actionText, onAction, ms = 3000) {
        toastEl.innerHTML = "";
        const span = document.createElement("span");
        span.textContent = message;

        const btn = document.createElement("button");
        btn.className = "toast-btn";
        btn.type = "button";
        btn.textContent = actionText;

        btn.addEventListener("click", () => {
          try { onAction?.(); } finally { toastEl.classList.remove("show"); }
        }, { once: true });

        toastEl.appendChild(span);
        toastEl.appendChild(btn);

        toastEl.classList.add("show");
        clearTimeout(toast._t);
        toast._t = setTimeout(() => toastEl.classList.remove("show"), ms);
      }

      /* =========================
         Drag & Drop (manual)
      ========================== */
      function canDrag() { return settings.sortMode === "manual"; }

      function getNoteContainerFromEventTarget(target) {
        return target.closest('.cat-list[data-role="catList"]');
      }

      function onDragStart(e) {
        if (!canDrag()) { e.preventDefault(); return; }
        if (isCoarsePointer) { e.preventDefault(); return; }

        const handle = e.target.closest(".drag-handle");
        if (!handle) { e.preventDefault(); return; }

        const noteEl = handle.closest(".note");
        if (!noteEl) { e.preventDefault(); return; }

        const id = noteEl.dataset.id;
        const note = getNoteById(id);
        if (!note) { e.preventDefault(); return; }

        const container = noteEl.closest(".cat-list");
        if (!container) { e.preventDefault(); return; }

        dragId = id;
        dragCtx = { id, pinned: !!note.pinned, categoryId: note.categoryId || GENERAL_CATEGORY_ID };

        noteEl.classList.add("dragging");

        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", dragId);

        try { e.dataTransfer.setDragImage(noteEl, 18, 18); } catch {}
      }

      function onDragOver(e) {
        if (!canDrag() || !dragId || !dragCtx) return;

        const container = getNoteContainerFromEventTarget(e.target);
        if (!container) return;

        const pinned = container.dataset.pinned === "true";
        const catId = container.dataset.categoryId;

        if (pinned !== dragCtx.pinned) return;
        if (catId !== dragCtx.categoryId) return;

        e.preventDefault();

        const draggingEl = document.querySelector(`.note[data-id="${cssEscape(dragId)}"]`);
        if (!draggingEl) return;

        const afterEl = getDragAfterElement(container, e.clientY);
        if (afterEl == null) container.appendChild(draggingEl);
        else container.insertBefore(draggingEl, afterEl);
      }

      function onDrop(e) {
        if (!canDrag() || !dragId || !dragCtx) return;

        const container = getNoteContainerFromEventTarget(e.target);
        if (!container) return;

        const pinned = container.dataset.pinned === "true";
        const catId = container.dataset.categoryId;

        if (pinned !== dragCtx.pinned) return;
        if (catId !== dragCtx.categoryId) return;

        e.preventDefault();

        saveManualOrderFromContainer(container);

        dragId = null;
        dragCtx = null;
        renderAll();
        toast("Orden guardado");
      }

      function onDragEnd() {
        document.querySelectorAll(".note.dragging").forEach(el => el.classList.remove("dragging"));
        dragId = null;
        dragCtx = null;
      }

      function getDragAfterElement(container, y) {
        const els = [...container.querySelectorAll(".note:not(.dragging):not(.placeholder)")];
        let closest = { offset: Number.NEGATIVE_INFINITY, element: null };

        for (const el of els) {
          const box = el.getBoundingClientRect();
          const offset = y - (box.top + box.height / 2);
          if (offset < 0 && offset > closest.offset) closest = { offset, element: el };
        }
        return closest.element;
      }

      function saveManualOrderFromContainer(container) {
        const pinned = container.dataset.pinned === "true";
        const categoryId = container.dataset.categoryId || GENERAL_CATEGORY_ID;

        const ids = [...container.querySelectorAll(".note:not(.placeholder)")].map(el => el.dataset.id);
        const groupNotes = notes.filter(n => !!n.pinned === pinned && (n.categoryId || GENERAL_CATEGORY_ID) === categoryId);

        const byId = new Map(groupNotes.map(n => [n.id, n]));
        for (let i = 0; i < ids.length; i++) {
          const n = byId.get(ids[i]);
          if (n) n.order = i * 1000;
        }

        saveDebounced();
      }

      /* ✅ Móvil: drag táctil */
      function onHandlePointerDown(e) {
        if (!isCoarsePointer) return;
        if (!canDrag()) return;
        if (pointerDrag) return;

        const handle = e.target.closest(".drag-handle");
        if (!handle) return;

        const noteEl = handle.closest(".note");
        if (!noteEl) return;

        const container = noteEl.closest(".cat-list");
        if (!container) return;

        if (noteEl.classList.contains("editing")) return;

        const startX = e.clientX;
        const startY = e.clientY;
        const pointerId = e.pointerId;

        pendingPress = {
          pointerId,
          startX, startY,
          lastX: startX, lastY: startY,
          noteEl, container
        };

        const t = setTimeout(() => {
          if (!pendingPress || pendingPress.pointerId !== pointerId) return;
          beginPointerDrag(pendingPress.noteEl, pendingPress.container, pointerId, pendingPress.lastX, pendingPress.lastY);
          pendingPress = null;
        }, 180);

        pendingPress.timer = t;

        const onMove = (ev) => {
          if (!pendingPress || ev.pointerId !== pointerId) return;
          pendingPress.lastX = ev.clientX;
          pendingPress.lastY = ev.clientY;

          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          if (Math.hypot(dx, dy) > 10) {
            clearTimeout(t);
            cleanup();
          }
        };

        const onUp = (ev) => {
          if (!pendingPress || ev.pointerId !== pointerId) return;
          clearTimeout(t);
          cleanup();
        };

        const cleanup = () => {
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", onUp);
          window.removeEventListener("pointercancel", onUp);
          pendingPress = null;
        };

        window.addEventListener("pointermove", onMove, { passive: true });
        window.addEventListener("pointerup", onUp, { passive: true });
        window.addEventListener("pointercancel", onUp, { passive: true });
      }

      function beginPointerDrag(noteEl, container, pointerId, clientX, clientY) {
        const rect = noteEl.getBoundingClientRect();

        const placeholder = document.createElement("div");
        placeholder.className = "note placeholder";
        placeholder.style.height = rect.height + "px";

        container.insertBefore(placeholder, noteEl);

        noteEl.classList.add("dragging", "dragging-touch");
        noteEl.style.position = "fixed";
        noteEl.style.zIndex = "9999";
        noteEl.style.width = rect.width + "px";
        noteEl.style.left = rect.left + "px";
        noteEl.style.top = rect.top + "px";

        document.body.appendChild(noteEl);
        document.body.classList.add("dragging-no-select");

        const offsetX = clientX - rect.left;
        const offsetY = clientY - rect.top;

        pointerDrag = { pointerId, noteEl, container, placeholder, offsetX, offsetY };

        const onMove = (e) => {
          if (!pointerDrag) return;
          if (e.pointerId !== pointerDrag.pointerId) return;

          e.preventDefault();

          const x = e.clientX;
          const y = e.clientY;

          pointerDrag.noteEl.style.left = (x - pointerDrag.offsetX) + "px";
          pointerDrag.noteEl.style.top  = (y - pointerDrag.offsetY) + "px";

          autoScrollWindow(y);

          const afterEl = getDragAfterElement(pointerDrag.container, y);
          if (afterEl == null) pointerDrag.container.appendChild(pointerDrag.placeholder);
          else pointerDrag.container.insertBefore(pointerDrag.placeholder, afterEl);
        };

        const onEnd = (e) => {
          if (!pointerDrag) return;
          if (e.pointerId !== pointerDrag.pointerId) return;

          e.preventDefault();

          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", onEnd);
          window.removeEventListener("pointercancel", onEnd);

          pointerDrag.container.insertBefore(pointerDrag.noteEl, pointerDrag.placeholder);
          pointerDrag.placeholder.remove();

          pointerDrag.noteEl.classList.remove("dragging", "dragging-touch");
          pointerDrag.noteEl.style.position = "";
          pointerDrag.noteEl.style.zIndex = "";
          pointerDrag.noteEl.style.width = "";
          pointerDrag.noteEl.style.left = "";
          pointerDrag.noteEl.style.top = "";

          document.body.classList.remove("dragging-no-select");

          saveManualOrderFromContainer(pointerDrag.container);
          pointerDrag = null;

          renderAll();
          toast("Orden guardado");
        };

        window.addEventListener("pointermove", onMove, { passive: false });
        window.addEventListener("pointerup", onEnd, { passive: false });
        window.addEventListener("pointercancel", onEnd, { passive: false });
      }

      function autoScrollWindow(clientY) {
        const margin = 70;
        const speed = 14;

        if (clientY < margin) window.scrollBy({ top: -speed, left: 0, behavior: "auto" });
        else if (clientY > window.innerHeight - margin) window.scrollBy({ top: speed, left: 0, behavior: "auto" });
      }

    })();
  </script>
</body>
</html>