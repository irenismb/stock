<!doctype html>
<html lang="es">
<head>
  <base target="_top">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#0b1020" />
  <title>Notas</title>

  <style>
    :root{
      --bg: #0b1020;
      --panel: rgba(17,26,51,.55);
      --panel2: rgba(17,26,51,.35);
      --text: #e8eeff;
      --muted: #a7b3dd;
      --line: rgba(255,255,255,.10);

      --fluor-blue:  #4F46E5;
      --fluor-blue2: #818CF8;

      --fluor-orange:  #F59E0B;
      --fluor-orange2: #FBBF24;

      --danger:  #EF4444;
      --danger2: #F87171;

      --ok:  #10B981;
      --ok2: #34D399;

      --btn:  #1F2A44;
      --btn2: #2B3A5E;

      --mark: rgba(255, 210, 0, .24);

      /* ✅ tamaños */
      --row-h: 44px;
      --btn-fixed-width: 44px;
      --btn-icon: 20px;

      /* ✅ categorías: color único */
      --cat-blue: #4F46E5;

      --radius: 12px;
    }

    [data-theme="light"]{
      --bg: #f7f8fc;
      --panel: rgba(255,255,255,.75);
      --panel2: rgba(255,255,255,.55);
      --text: #101428;
      --muted: #4a587e;
      --line: rgba(16,20,40,.12);

      --btn: #e7ebff;
      --btn2:#f2f4ff;

      --mark: rgba(255, 200, 0, .22);
    }

    *{ box-sizing: border-box; }

    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(21,34,74,.9) 0%, var(--bg) 55%, rgba(7,10,20,.95) 100%);
    }

    [data-theme="light"] body{
      background: radial-gradient(1200px 600px at 20% 0%, rgba(140,165,255,.35) 0%, var(--bg) 55%, rgba(255,255,255,.9) 100%);
    }

    /* ✅ evita selección durante drag táctil */
    body.dragging-no-select, body.dragging-no-select *{
      user-select: none !important;
      -webkit-user-select: none !important;
    }

    .app{
      max-width: 1080px;
      margin: 18px auto;
      padding: 14px;
    }

    /* ✅ Header fijo en móvil + sin scroll horizontal */
    .header{
      margin-bottom: 12px;
      position: sticky;
      top: 0;
      z-index: 60;
      padding: 10px 0;
      border-bottom: 1px solid var(--line);
      background: rgba(11,16,32,.72);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    [data-theme="light"] .header{
      background: rgba(247,248,252,.82);
    }

    /* ✅ Barra superior: PC en UNA FILA (sin overflow) */
    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-start;
      flex-wrap:nowrap;       /* ✅ PC: 1 fila */
      overflow: hidden;       /* ✅ sin barra horizontal */
    }

    .searchbox{
      display:flex;
      align-items:stretch;
      flex: 1 1 auto;
      min-width: 0;                 /* ✅ permite encoger sin overflow */
      height: var(--row-h);
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    [data-theme="light"] .searchbox{ background: rgba(255,255,255,.8); }

    .searchbox input{
      width: 100%;
      min-width: 0;
      padding: 10px 12px;
      border: none;
      outline:none;
      background: transparent;
      color: var(--text);
    }

    .searchbox:focus-within{
      border-color: rgba(0,183,255,.55);
      box-shadow: 0 0 0 3px rgba(0,183,255,.18);
    }

    /* ✅ Botón limpiar: mismo tamaño que los demás */
    .icon-btn{
      width: var(--btn-fixed-width);
      min-width: var(--btn-fixed-width);
      height: 100%;
      border: none;
      cursor:pointer;
      background: rgba(0,0,0,.10);
      border-left: 1px solid var(--line);
      color: var(--text);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 0;
    }
    [data-theme="light"] .icon-btn{ background: rgba(255,255,255,.55); }
    .icon-btn:hover{ filter: brightness(1.08); }

    .icon-btn svg{
      width: var(--btn-icon);
      height: var(--btn-icon);
      stroke: currentColor;
      fill: none;
      stroke-width: 2.5;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    /* ✅ Botones base (cuadrados) */
    .btn{
      width: var(--btn-fixed-width);
      min-width: var(--btn-fixed-width);
      height: var(--row-h);
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      color: var(--text);
      padding: 0;
      border-radius: 10px;
      cursor:pointer;
      user-select:none;
      transition: transform .05s ease, filter .15s ease, box-shadow .15s ease, border-color .15s ease;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      white-space:nowrap;
      overflow:hidden;
      flex: 0 0 auto;
    }
    .btn:active{ transform: translateY(1px); }
    .btn:hover{ filter: brightness(1.08); }

    .btn svg{
      width: var(--btn-icon);
      height: var(--btn-icon);
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      flex: 0 0 auto;
    }

    .btn-add{
      border-color: rgba(129,140,248,.85);
      background: linear-gradient(180deg, var(--fluor-blue2), var(--fluor-blue));
      color: #ffffff;
      box-shadow: 0 0 18px rgba(79,70,229,.22);
    }

    .btn-copy{
      border-color: rgba(16,185,129,.70);
      background: linear-gradient(180deg, var(--ok2), var(--ok));
      color: #052014;
      box-shadow: 0 0 16px rgba(16,185,129,.20);
    }

    .btn-paste{
      border-color: rgba(245,158,11,.80);
      background: linear-gradient(180deg, var(--fluor-orange2), var(--fluor-orange));
      color: #1a1200;
      box-shadow: 0 0 18px rgba(245,158,11,.20);
    }

    .btn-danger{
      border-color: rgba(239,68,68,.75);
      background: linear-gradient(180deg, var(--danger2), var(--danger));
      color: #ffffff;
      box-shadow: 0 0 16px rgba(239,68,68,.20);
    }

    .btn-ghost{
      background: rgba(0,0,0,.12);
      border-color: rgba(255,255,255,.14);
      box-shadow: none;
    }
    [data-theme="light"] .btn-ghost{ background: rgba(255,255,255,.55); }

    /* ✅ Select como control cuadrado con icono (sin texto visible) */
    .selectwrap{
      position: relative;
      width: var(--btn-fixed-width);
      min-width: var(--btn-fixed-width);
      height: var(--row-h);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      flex: 0 0 auto;
    }
    [data-theme="light"] .selectwrap{ border-color: rgba(16,20,40,.14); }

    .selectwrap svg{
      width: 18px;
      height: 18px;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      color: var(--text);
      opacity: .95;
      pointer-events:none;
    }

    .selectwrap select{
      position:absolute;      /* ✅ captura clic/tap */
      inset:0;
      width:100%;
      height:100%;
      opacity:0;              /* ✅ oculto, pero funcional */
      cursor:pointer;
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
      border:none;
      outline:none;
      background: transparent;
    }

    .selectwrap:focus-within{
      border-color: rgba(0,183,255,.55);
      box-shadow: 0 0 0 3px rgba(0,183,255,.18);
    }

    /* ✅ Agrupaciones dentro de la barra superior */
    .top-controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex: 0 0 auto;
      min-width: 0;
    }

    .toolbar2{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap:nowrap;   /* ✅ PC: 1 fila */
      flex: 0 0 auto;
    }

    .count-pill{
      height: var(--row-h);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 0 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.10);
      color: var(--muted);
      font-size: 13px;
      font-weight: 800;
      white-space:nowrap;
    }
    [data-theme="light"] .count-pill{ background: rgba(255,255,255,.55); }

    .list{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      overflow:hidden;
    }

    .section{ border-top: 1px solid var(--line); }
    .section:first-child{ border-top:none; }

    /* ✅ Secciones colapsables */
    .section.collapsed .section-body{ display:none; }

    .section-title{
      padding: 10px 12px;
      font-weight: 800;
      letter-spacing:.2px;
      color: var(--muted);
      background: var(--panel2);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .section-title.section-toggle{
      cursor:pointer;
      user-select:none;
    }
    .section-title.section-toggle:focus{
      outline:none;
      box-shadow: 0 0 0 3px rgba(0,183,255,.18);
    }

    .section-chevron{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width: 24px;
      height: 24px;
      opacity: .95;
      color: var(--muted);
      flex: 0 0 auto;
    }
    .section-title.section-toggle:hover .section-chevron{ color: var(--text); }
    .section-chevron svg{ width: 18px; height: 18px; }

    .section-body{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    /* ✅ Categorías */
    .cat-group{
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow:hidden;
      background: rgba(0,0,0,.10);
    }
    [data-theme="light"] .cat-group{ background: rgba(255,255,255,.55); }

    .cat-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      background: var(--panel2);
    }

    .cat-left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }

    .cat-toggle{
      width: 34px;
      height: 34px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.12);
      color: var(--muted);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      flex: 0 0 auto;
    }
    .cat-toggle:hover{ color: var(--text); }
    .cat-toggle svg{ width: 18px; height: 18px; }

    .cat-name{
      font-weight: 800;
      letter-spacing: .2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width: 0;
    }

    .cat-pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--text);
      background: rgba(0,0,0,.12);
      flex: 0 0 auto;
      font-size: 12px;
      font-weight: 800;
    }

    .cat-dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.22);
      flex: 0 0 auto;
      background: var(--cat-blue);
    }
    [data-theme="light"] .cat-dot{ border-color: rgba(16,20,40,.18); }

    .cat-right{
      display:flex;
      align-items:center;
      gap:8px;
      flex: 0 0 auto;
    }

    .cat-list{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .cat-group.collapsed .cat-list{ display:none; }

    .cat-empty{
      padding: 10px 12px;
      border: 1px dashed var(--line);
      border-radius: 12px;
      color: var(--muted);
      background: rgba(0,0,0,.10);
      font-size: 13px;
      text-align:center;
    }
    [data-theme="light"] .cat-empty{ background: rgba(255,255,255,.45); }

    /* ✅ Nota */
    .note{
      display:grid;
      grid-template-columns: 34px 1fr auto;
      gap: 10px;
      align-items:center;
      padding: 10px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(0,0,0,.12);
    }
    [data-theme="light"] .note{ background: rgba(255,255,255,.55); }
    .note[hidden]{ display:none; }

    .drag-handle{
      height: var(--row-h);
      border: 1px solid var(--line);
      background: rgba(0,0,0,.12);
      border-radius: 10px;
      cursor: grab;
      color: var(--muted);
      font-size: 18px;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      touch-action: none;
      -webkit-touch-callout: none;
    }
    .drag-handle:active{ cursor: grabbing; }
    .drag-handle:hover{ color: var(--text); }

    .note.dragging{
      opacity:.55;
      outline: 2px dashed rgba(0,183,255,.45);
      outline-offset: 2px;
    }

    .note.placeholder{
      background: transparent !important;
      border: 2px dashed rgba(0,183,255,.45) !important;
    }

    .note.dragging-touch{
      opacity: .92;
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      pointer-events: none;
      transform: rotate(.2deg);
    }

    .content{ min-width: 0; }

    /* ✅ Vista (solo lectura en la lista). Edición: modal */
    .note-view{
      height: var(--row-h);
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      cursor: pointer;
      line-height: 1.4;
      word-break: break-word;

      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display:flex;
      align-items:center;
    }
    [data-theme="light"] .note-view{ background: rgba(255,255,255,.75); }

    .note-view:focus{
      outline:none;
      border-color: rgba(0,255,153,.40);
      box-shadow: 0 0 0 3px rgba(0,255,153,.12);
    }

    .note-view .placeholder{ color: var(--muted); }

    mark{
      background: var(--mark);
      color: inherit;
      border-radius: 4px;
      padding: 0 .12em;
    }

    /* ✅ Acciones por nota: sin scroll horizontal */
    .actions{
      min-height: var(--row-h);
      display:flex;
      flex-direction:row;
      gap:8px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap:nowrap;
      overflow: hidden;
      max-width: none;
    }

    .btn-pin{
      border-color: rgba(129,140,248,.85);
      background: linear-gradient(180deg, rgba(129,140,248,.95), rgba(79,70,229,.95));
      color: #ffffff;
      box-shadow: 0 0 16px rgba(79,70,229,.18);
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.78);
      color: var(--text);
      border: 1px solid rgba(255,255,255,.16);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 13px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      max-width: min(860px, 92vw);
      display:flex;
      gap:10px;
      align-items:center;
    }
    [data-theme="light"] .toast{ background: rgba(20,25,40,.88); }

    .toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(-4px);
      pointer-events:auto;
    }

    .toast .toast-btn{
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.12);
      color: var(--text);
      padding: 7px 10px;
      border-radius: 10px;
      cursor:pointer;
      font-weight: 650;
    }
    .toast .toast-btn:hover{ filter: brightness(1.08); }

    .empty{
      padding: 18px 14px;
      text-align:center;
      color: var(--muted);
      border-top: 1px solid var(--line);
    }

    .empty-title{
      font-weight: 800;
      color: var(--text);
      margin-bottom: 4px;
    }

    .sr-only{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }

    /* ✅ Modales */
    dialog.modal{
      border: none;
      padding: 0;
      border-radius: 14px;
      width: min(820px, 92vw);
      color: var(--text);
      background: rgba(10,14,28,.92);
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
      overflow:hidden;
    }
    [data-theme="light"] dialog.modal{
      background: rgba(245,247,255,.96);
      color: var(--text);
    }
    dialog::backdrop{ background: rgba(0,0,0,.55); }

    .modal-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      background: var(--panel2);
    }
    .modal-title{ font-weight: 900; letter-spacing: .2px; }
    .modal-body{
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    /* ✅ Modal categorías */
    .cat-table{
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .cat-row{
      display:grid;
      grid-template-columns: 1fr 34px 34px 44px;
      gap:10px;
      align-items:center;
      padding: 10px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(0,0,0,.10);
    }
    [data-theme="light"] .cat-row{ background: rgba(255,255,255,.65); }

    .cat-row input[type="text"]{
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.16);
      color: var(--text);
      outline:none;
    }
    [data-theme="light"] .cat-row input[type="text"]{ background: rgba(255,255,255,.9); }

    .mini-btn{
      width: 34px;
      height: 34px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.12);
      color: var(--muted);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .mini-btn:hover{ color: var(--text); }
    .mini-btn[disabled]{ opacity:.35; cursor:not-allowed; }

    .cat-add{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      padding-top: 6px;
      border-top: 1px solid var(--line);
      margin-top: 4px;
    }
    .cat-add input[type="text"]{
      flex: 1 1 260px;
      min-width: 220px;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.16);
      color: var(--text);
      outline:none;
    }
    [data-theme="light"] .cat-add input[type="text"]{ background: rgba(255,255,255,.9); }

    /* ✅ Modal nota */
    .note-meta{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-weight: 800;
      font-size: 13px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.10);
      border-radius: 12px;
      padding: 10px 12px;
    }
    [data-theme="light"] .note-meta{
      background: rgba(255,255,255,.7);
    }

    .note-meta .meta-text{
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    .note-editor{
      width:100%;
      min-height: min(62vh, 560px);
      resize: vertical;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
      font-size: 16px;
      line-height: 1.45;
      letter-spacing: .1px;
      white-space: pre-wrap;
    }
    [data-theme="light"] .note-editor{
      background: rgba(255,255,255,.85);
    }
    .note-editor:focus{
      border-color: rgba(0,255,153,.40);
      box-shadow: 0 0 0 3px rgba(0,255,153,.12);
    }

    /* ✅ MÓVIL: filas de botones 7 + 3 centradas */
    @media (max-width: 860px){
      :root{
        --btn-fixed-width: 36px;
        --btn-icon: 16px;
        --row-h: 40px;
      }

      .app{ margin: 12px auto; padding: 12px; }

      .topbar{
        flex-direction: column;
        align-items: stretch;
        flex-wrap: nowrap;
        overflow: visible;
      }

      /* ✅ Orden correcto en móvil */
      .searchbox{ order: 1; }
      .toolbar2{ order: 2; }      /* 1ra fila (7) */
      .top-controls{ order: 3; }  /* 2da fila (3) */

      .searchbox{
        flex: 1 1 100%;
      }

      /* ✅ 1ra fila: 7 elementos (toolbar2), centrada */
      .toolbar2{
        width: 100%;
        display: grid;
        grid-template-columns: repeat(7, var(--btn-fixed-width));
        justify-content: center;
        gap: 10px;
        overflow: visible;
      }

      /* ✅ 2da fila: 3 elementos (top-controls), centrada */
      .top-controls{
        width: 100%;
        justify-content: center;
        flex-wrap: nowrap;
        overflow: visible;
      }

      .actions{
        flex-wrap:wrap;
        justify-content:flex-end;
      }

      .note-editor{
        min-height: min(66vh, 560px);
        font-size: 16px;
      }

      /* ✅ Meta en móvil: mostrar completa (sin recorte) */
      .note-meta{
        align-items:flex-start;
      }
      .note-meta .meta-text{
        white-space: normal;
        overflow: visible;
        text-overflow: clip;
        line-height: 1.25;
      }
    }

    @media (prefers-reduced-motion: reduce){
      *{ transition: none !important; }
    }
  </style>
</head>

<body>
  <div class="app">
    <header class="header">
      <div class="topbar" aria-label="Barra superior">

        <div class="searchbox" role="search">
          <label class="sr-only" for="search">Buscar</label>
          <input id="search" type="text" autocomplete="off" placeholder="Buscar… (ignora tildes)" />
          <button id="clearSearch" class="icon-btn" type="button" aria-label="Limpiar búsqueda" title="Limpiar">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M6 6l12 12"></path>
              <path d="M18 6l-12 12"></path>
            </svg>
          </button>
        </div>

        <!-- ✅ 2da fila móvil (3 elementos): categoría, orden, conteo -->
        <div class="top-controls" role="group" aria-label="Controles superiores">
          <div class="selectwrap" aria-label="Filtro de categoría" title="Categoría">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M4 6h16"></path>
              <path d="M7 12h10"></path>
              <path d="M10 18h4"></path>
            </svg>
            <select id="catFilter" aria-label="Filtrar por categoría"></select>
          </div>

          <div class="selectwrap" aria-label="Ordenar" title="Orden">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M11 5h10"></path>
              <path d="M11 9h7"></path>
              <path d="M11 13h5"></path>
              <path d="M11 17h3"></path>
              <path d="M3 7l2-2 2 2"></path>
              <path d="M5 5v14"></path>
            </svg>
            <select id="sort" aria-label="Ordenar notas">
              <option value="manual">Manual</option>
              <option value="updated_desc">Actualizadas</option>
              <option value="created_desc">Creadas</option>
              <option value="alpha_asc">A-Z</option>
            </select>
          </div>

          <span id="count" class="count-pill" aria-label="Conteo"></span>
        </div>

        <!-- ✅ 1ra fila móvil (7 elementos): acciones -->
        <div class="toolbar2" role="group" aria-label="Acciones">
          <button id="catBtn" class="btn btn-ghost" type="button" aria-label="Administrar categorías" title="Administrar categorías">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M3 7a2 2 0 0 1 2-2h5l2 2h7a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
              <path d="M3 9h18"></path>
            </svg>
            <span class="sr-only">Categorías</span>
          </button>

          <button id="newCatTop" class="btn btn-add" type="button" aria-label="Crear nueva categoría" title="Nueva categoría">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 5v14"></path>
              <path d="M5 12h14"></path>
            </svg>
            <span class="sr-only">Nueva categoría</span>
          </button>

          <button id="newNote" class="btn btn-add" type="button" aria-label="Nueva nota" title="Nueva nota">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
              <path d="M14 2v6h6"></path>
              <path d="M12 12v6"></path>
              <path d="M9 15h6"></path>
            </svg>
            <span class="sr-only">Nueva nota</span>
          </button>

          <button id="exportJson" class="btn" type="button" aria-label="Exportar JSON" title="Exportar JSON">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 3v10"></path>
              <path d="M8 9l4 4 4-4"></path>
              <path d="M4 17h16v4H4z"></path>
              <path d="M9 8l-2 2 2 2"></path>
              <path d="M15 8l2 2-2 2"></path>
            </svg>
            <span class="sr-only">Exportar JSON</span>
          </button>

          <button id="exportTxt" class="btn" type="button" aria-label="Exportar TXT" title="Exportar TXT">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 3v10"></path>
              <path d="M8 9l4 4 4-4"></path>
              <path d="M4 17h16v4H4z"></path>
              <path d="M7 8h10"></path>
              <path d="M7 11h8"></path>
            </svg>
            <span class="sr-only">Exportar TXT</span>
          </button>

          <input id="importFile" type="file" accept=".json,.txt,application/json,text/plain" hidden />
          <button id="importBtn" class="btn" type="button" aria-label="Importar" title="Importar">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 21V11"></path>
              <path d="M16 15l-4-4-4 4"></path>
              <path d="M4 3h16v6H4z"></path>
            </svg>
            <span class="sr-only">Importar</span>
          </button>

          <button id="themeBtn" class="btn btn-ghost" type="button" aria-label="Cambiar tema" title="Tema">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 3v2"></path>
              <path d="M12 19v2"></path>
              <path d="M4.22 4.22l1.42 1.42"></path>
              <path d="M18.36 18.36l1.42 1.42"></path>
              <path d="M3 12h2"></path>
              <path d="M19 12h2"></path>
              <path d="M4.22 19.78l1.42-1.42"></path>
              <path d="M18.36 5.64l1.42-1.42"></path>
              <path d="M12 7a5 5 0 1 0 0 10a5 5 0 0 0 0-10z"></path>
            </svg>
            <span class="sr-only">Tema</span>
          </button>
        </div>
      </div>
    </header>

    <main class="list" aria-label="Notas">
      <section id="pinnedSection" class="section" hidden>
        <div id="pinnedTitle" class="section-title section-toggle" role="button" tabindex="0" aria-label="Mostrar/ocultar fijadas">
          <span>Fijadas</span>
          <span id="pinnedChevron" class="section-chevron" aria-hidden="true"></span>
        </div>
        <div id="pinnedList" class="section-body"></div>
      </section>

      <section id="notesSection" class="section">
        <div id="notesTitle" class="section-title section-toggle" role="button" tabindex="0" aria-label="Mostrar/ocultar categorías">
          <span>Categorías</span>
          <span id="notesChevron" class="section-chevron" aria-hidden="true"></span>
        </div>
        <div id="notesList" class="section-body"></div>
      </section>

      <div id="empty" class="empty" hidden>
        <div class="empty-title">Sin resultados</div>
        <div class="empty-sub">Prueba con otra búsqueda o crea una nota nueva.</div>
      </div>
    </main>
  </div>

  <!-- ✅ Modal categorías -->
  <dialog id="catDialog" class="modal" aria-label="Gestión de categorías">
    <div class="modal-head">
      <div class="modal-title">Categorías</div>
      <button id="catClose" class="btn btn-ghost" type="button" aria-label="Cerrar" title="Cerrar">
        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M6 6l12 12"></path>
          <path d="M18 6l-12 12"></path>
        </svg>
      </button>
    </div>
    <div class="modal-body">
      <div class="cat-table" id="catTable"></div>

      <div class="cat-add">
        <input id="catNewName" type="text" placeholder="Nueva categoría (ej. Trabajo)" aria-label="Nombre de la nueva categoría" />
        <button id="catAddBtn" class="btn btn-add" type="button" aria-label="Agregar categoría" title="Agregar categoría">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M12 5v14"></path>
            <path d="M5 12h14"></path>
          </svg>
        </button>
      </div>
    </div>
  </dialog>

  <!-- ✅ Modal edición de nota (autoguardado) -->
  <dialog id="noteDialog" class="modal" aria-label="Editar nota">
    <div class="modal-head">
      <div class="modal-title">Editar nota</div>
      <button id="noteClose" class="btn btn-ghost" type="button" aria-label="Cerrar" title="Cerrar">
        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M6 6l12 12"></path>
          <path d="M18 6l-12 12"></path>
        </svg>
      </button>
    </div>
    <div class="modal-body">
      <div class="note-meta" aria-label="Información de la nota">
        <div id="noteMeta" class="meta-text"></div>
        <button id="noteInsertDate" class="btn btn-ghost" type="button" aria-label="Insertar fecha" title="Insertar fecha (aaaa-mm-dd)">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M8 2v3"></path>
            <path d="M16 2v3"></path>
            <path d="M3 7h18"></path>
            <path d="M5 5h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2z"></path>
            <path d="M8 11h4"></path>
            <path d="M8 15h8"></path>
          </svg>
        </button>
      </div>
      <textarea id="noteEditor" class="note-editor" spellcheck="false" placeholder="Escribe aquí… (se guarda automáticamente)"></textarea>
    </div>
  </dialog>

  <div id="toast" class="toast" role="status" aria-live="polite" aria-atomic="true"></div>

  <script>
    (() => {
      "use strict";

      /* =========================
         Backend: GitHub Pages -> Apps Script Web App API
         - Lee con JSONP (GET) para evitar CORS
         - Guarda con POST vía iframe + postMessage (evita CORS)
         - ✅ SIN TOKEN (abierto)
      ========================== */

      const API_URL = "https://script.google.com/macros/s/AKfycbyNE12DPGcX6w9zTQRjCAej-bxeQM4GDCpTrVhlERhj_cptdO7uFXlDJ4aDgt_230_V/exec";
      const AUTOSYNC_MS = 15000;

      function isLikelyBadApiUrl_(u) {
        const s = String(u || "");
        return !s || s.includes("XXXXXXXX") || s.includes("/macros/library/") || s.includes("/library/d/");
      }

      function jsonp_(params) {
        return new Promise((resolve, reject) => {
          if (isLikelyBadApiUrl_(API_URL)) {
            reject(new Error("Configura API_URL con tu /exec real (no /library)."));
            return;
          }

          const cb = "__jsonp_cb_" + Math.random().toString(16).slice(2);
          const url = new URL(API_URL);
          const q = new URLSearchParams(params || {});
          q.set("callback", cb);
          q.set("t", String(Date.now()));
          url.search = q.toString();

          let done = false;
          const cleanup = () => {
            if (done) return;
            done = true;
            try { delete window[cb]; } catch {}
            script.remove();
            clearTimeout(timer);
          };

          window[cb] = (data) => { cleanup(); resolve(data); };

          const script = document.createElement("script");
          script.src = url.toString();
          script.async = true;
          script.onerror = () => { cleanup(); reject(new Error("JSONP error (revisa API_URL/deploy)")); };

          const timer = setTimeout(() => {
            cleanup();
            reject(new Error("Timeout leyendo datos (revisa Apps Script)"));
          }, 12000);

          document.head.appendChild(script);
        });
      }

      async function apiGetState_() {
        const data = await jsonp_({ action: "getState" });
        if (data && data.ok === false) throw new Error(data.error || "Error getState");
        return data;
      }

      // Guardado por POST via iframe (sin CORS)
      const SAVE_IFRAME_NAME = "notas_save_iframe_v2";
      let saveBridgeReady = false;
      let saveBusy = false;
      let saveQueuedState = null;

      let saveIframeEl = null;
      let saveFormEl = null;
      let inActionEl = null;
      let inPayloadEl = null;

      function ensureSaveBridge_() {
        if (saveBridgeReady) return;
        if (isLikelyBadApiUrl_(API_URL)) return;

        saveIframeEl = document.createElement("iframe");
        saveIframeEl.name = SAVE_IFRAME_NAME;
        saveIframeEl.style.position = "fixed";
        saveIframeEl.style.left = "-9999px";
        saveIframeEl.style.top = "-9999px";
        saveIframeEl.style.width = "1px";
        saveIframeEl.style.height = "1px";
        saveIframeEl.setAttribute("aria-hidden", "true");

        saveFormEl = document.createElement("form");
        saveFormEl.method = "POST";
        saveFormEl.action = API_URL;
        saveFormEl.target = SAVE_IFRAME_NAME;
        saveFormEl.acceptCharset = "utf-8";
        saveFormEl.style.position = "fixed";
        saveFormEl.style.left = "-9999px";
        saveFormEl.style.top = "-9999px";

        inActionEl = document.createElement("input");
        inActionEl.type = "hidden";
        inActionEl.name = "action";
        inActionEl.value = "saveAll";

        inPayloadEl = document.createElement("input");
        inPayloadEl.type = "hidden";
        inPayloadEl.name = "payload";

        saveFormEl.appendChild(inActionEl);
        saveFormEl.appendChild(inPayloadEl);

        document.body.appendChild(saveIframeEl);
        document.body.appendChild(saveFormEl);

        saveBridgeReady = true;
      }

      function apiSaveAllFireAndForget_(state) {
        try {
          if (isLikelyBadApiUrl_(API_URL)) return;
          ensureSaveBridge_();
          if (!saveBridgeReady) return;

          inPayloadEl.value = JSON.stringify(state);
          saveFormEl.submit();
        } catch {}
      }

      function apiSaveAll_(state) {
        saveQueuedState = state;

        if (saveBusy) return Promise.resolve({ ok: true, queued: true });

        return new Promise((resolve, reject) => {
          if (isLikelyBadApiUrl_(API_URL)) { reject(new Error("Configura API_URL")); return; }

          ensureSaveBridge_();
          if (!saveBridgeReady) { reject(new Error("No se pudo inicializar puente de guardado.")); return; }

          const runOne = () => {
            if (!saveQueuedState) { saveBusy = false; resolve({ ok: true, empty: true }); return; }
            const payloadState = saveQueuedState;
            saveQueuedState = null;

            saveBusy = true;

            const onMsg = (ev) => {
              const d = ev && ev.data;
              if (!d || d.type !== "notas_saveAll") return;

              window.removeEventListener("message", onMsg);

              if (d.ok) {
                if (saveQueuedState) return runOne();
                saveBusy = false;
                resolve(d);
              } else {
                saveBusy = false;
                reject(new Error(d.error || "Error guardando"));
              }
            };

            window.addEventListener("message", onMsg);

            const t = setTimeout(() => {
              window.removeEventListener("message", onMsg);
              if (saveQueuedState) return runOne();
              saveBusy = false;
              resolve({ ok: true, timeout: true });
            }, 12000);

            try {
              inPayloadEl.value = JSON.stringify(payloadState);
              saveFormEl.submit();
            } catch (e) {
              clearTimeout(t);
              window.removeEventListener("message", onMsg);
              saveBusy = false;
              reject(e);
            }
          };

          runOne();
        });
      }

      /* =========================
         Storage (solo UI)
      ========================== */
      const THEME_KEY = "notas_web_theme_v1";
      const SETTINGS_KEY = "notas_web_settings_v1";

      /* =========================
         Model
      ========================== */
      const GENERAL_CATEGORY_ID = "general";
      const CATEGORY_COLOR = "#4F46E5";

      const DEFAULT_GENERAL_CATEGORY = {
        id: GENERAL_CATEGORY_ID,
        name: "General",
        color: CATEGORY_COLOR,
        order: 0,
        collapsed: true
      };

      const DEFAULT_SETTINGS = {
        sortMode: "manual",
        theme: "auto",
        categoryFilter: "all",
        pinnedSectionCollapsed: false,
        notesSectionCollapsed: false
      };

      const Icons = {
        pin: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M14 4h-4v5l-2 2v3h8v-3l-2-2z"></path>
            <path d="M12 14v7"></path>
          </svg>`,
        unpin: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M14 4h-4v5l-2 2v3h8v-3l-2-2z"></path>
            <path d="M12 14v7"></path>
            <path d="M4 4l16 16"></path>
          </svg>`,
        copy: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <rect x="9" y="9" width="10" height="10" rx="2"></rect>
            <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1"></path>
          </svg>`,
        paste: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M9 4h6"></path>
            <path d="M9 4a2 2 0 0 0-2 2v1h10V6a2 2 0 0 0-2-2"></path>
            <path d="M7 7h10v15H7z"></path>
          </svg>`,
        clear: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M20 20H8"></path>
            <path d="M6 14l8-8 4 4-8 8H6z"></path>
            <path d="M14 6l4 4"></path>
          </svg>`,
        trash: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M3 6h18"></path>
            <path d="M8 6V4h8v2"></path>
            <path d="M19 6l-1 16H6L5 6"></path>
            <path d="M10 11v6"></path>
            <path d="M14 11v6"></path>
          </svg>`,
        chevronDown: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M6 9l6 6 6-6"></path>
          </svg>`,
        chevronRight: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M9 6l6 6-6 6"></path>
          </svg>`,
        plus: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M12 5v14"></path>
            <path d="M5 12h14"></path>
          </svg>`,
        tag: `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M20 13l-7 7-10-10V3h7z"></path>
            <path d="M7 7h.01"></path>
          </svg>`
      };

      const $ = (id) => document.getElementById(id);

      const searchEl = $("search");
      const clearSearchEl = $("clearSearch");
      const sortEl = $("sort");
      const catFilterEl = $("catFilter");
      const newCatTopEl = $("newCatTop");

      const catBtnEl = $("catBtn");
      const newNoteEl = $("newNote");
      const exportJsonEl = $("exportJson");
      const exportTxtEl = $("exportTxt");
      const importBtnEl = $("importBtn");
      const importFileEl = $("importFile");
      const themeBtnEl = $("themeBtn");
      const countEl = $("count");

      const pinnedSectionEl = $("pinnedSection");
      const pinnedTitleEl = $("pinnedTitle");
      const pinnedChevronEl = $("pinnedChevron");
      const pinnedListEl = $("pinnedList");

      const notesSectionEl = $("notesSection");
      const notesTitleEl = $("notesTitle");
      const notesChevronEl = $("notesChevron");
      const notesListEl = $("notesList");

      const emptyEl = $("empty");
      const toastEl = $("toast");

      const catDialogEl = $("catDialog");
      const catCloseEl = $("catClose");
      const catTableEl = $("catTable");
      const catNewNameEl = $("catNewName");
      const catAddBtnEl = $("catAddBtn");

      const noteDialogEl = $("noteDialog");
      const noteCloseEl = $("noteClose");
      const noteMetaEl = $("noteMeta");
      const noteEditorEl = $("noteEditor");
      const noteInsertDateEl = $("noteInsertDate");

      let notes = [];
      let categories = [];
      let settings = { ...DEFAULT_SETTINGS };
      let undoState = null;

      /* Drag state */
      let dragId = null;
      let dragCtx = null;

      /* ✅ drag táctil */
      let pendingPress = null;
      let pointerDrag = null;
      const isCoarsePointer = !!(window.matchMedia && window.matchMedia("(pointer: coarse)").matches);
      const supportsPointer = "PointerEvent" in window;

      /* Auto-sync snapshot */
      let lastSnapshot = "";

      /* Modal nota */
      let activeNoteId = null;
      const refreshPreviewDebounced = debounce(() => applySearchAndHighlights(), 80);

      document.addEventListener("DOMContentLoaded", () => { init(); });

      async function init() {
        try {
          if (isLikelyBadApiUrl_(API_URL)) {
            toast("Configura API_URL con tu /exec real (Apps Script Web App)");
            console.error("API_URL inválida:", API_URL);
            return;
          }

          const remote = await apiGetState_();
          notes = Array.isArray(remote?.notes) ? remote.notes : [];
          categories = Array.isArray(remote?.categories) ? remote.categories : [];

          const localSettings = safeParse(localStorage.getItem(SETTINGS_KEY), {}) || {};
          settings = { ...DEFAULT_SETTINGS, ...(remote?.settings || {}), ...localSettings };

          const savedTheme = localStorage.getItem(THEME_KEY);
          if (savedTheme && ["auto","dark","light"].includes(savedTheme)) settings.theme = savedTheme;

          ensureGeneralCategory();
          sanitizeNotesCategoryIds();

          applyTheme(settings.theme);
          sortEl.value = settings.sortMode;

          bindEvents();

          renderCategoryFilter();
          syncTopSelectTitles_();
          renderAll();

          if ((categories?.length || 0) === 0 && (notes?.length || 0) === 0) {
            saveDebounced();
          }

          lastSnapshot = makeSnapshot_(categories, notes);
          startAutoSync();
        } catch (err) {
          toast("Error cargando datos (revisa API_URL /exec y despliegue)");
          console.error(err);
        }
      }

      function bindEvents() {
        const onSearch = debounce(() => applySearchAndHighlights(), 60);
        searchEl.addEventListener("input", onSearch);

        clearSearchEl.addEventListener("click", () => {
          searchEl.value = "";
          searchEl.focus();
          applySearchAndHighlights();
        });

        sortEl.addEventListener("change", () => {
          settings.sortMode = sortEl.value;
          saveUISettings_();
          syncTopSelectTitles_();
          renderAll();
          toast("Orden actualizado");
        });

        catFilterEl.addEventListener("change", () => {
          settings.categoryFilter = catFilterEl.value;
          saveUISettings_();
          syncTopSelectTitles_();
          renderAll();
          toast("Filtro actualizado");
        });

        newCatTopEl.addEventListener("click", () => {
          openCatDialog({ focusNew: true });
        });

        catBtnEl.addEventListener("click", () => {
          openCatDialog({ focusNew: false });
        });

        catCloseEl.addEventListener("click", () => closeCatDialog());
        catDialogEl.addEventListener("click", (e) => {
          const rect = catDialogEl.getBoundingClientRect();
          const inDialog = (
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top  && e.clientY <= rect.bottom
          );
          if (!inDialog) closeCatDialog();
        });

        catAddBtnEl.addEventListener("click", () => addCategoryFromForm());
        catNewNameEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") { e.preventDefault(); addCategoryFromForm(); }
        });

        newNoteEl.addEventListener("click", () => {
          const catId = (settings.categoryFilter && settings.categoryFilter !== "all")
            ? settings.categoryFilter
            : GENERAL_CATEGORY_ID;

          const n = createNote({ afterId: null, pinned: false, categoryId: catId });
          notes.push(n);
          if (settings.sortMode === "manual") renormalizeOrders(false, catId);
          saveDebounced();
          renderAll();
          focusNote(n.id);
          toast("Nota creada");
        });

        exportJsonEl.addEventListener("click", exportJSON);
        exportTxtEl.addEventListener("click", exportTXT);

        importBtnEl.addEventListener("click", () => importFileEl.click());
        importFileEl.addEventListener("change", async () => {
          const file = importFileEl.files && importFileEl.files[0];
          importFileEl.value = "";
          if (!file) return;
          await importFile(file);
        });

        themeBtnEl.addEventListener("click", () => {
          settings.theme = nextTheme(settings.theme);
          localStorage.setItem(THEME_KEY, settings.theme);
          applyTheme(settings.theme);
          toast(`Tema: ${themeLabel(settings.theme)}`);
        });

        /* ✅ Toggle secciones por título: Fijadas / Categorías */
        const toggleWith = (kind) => {
          if (kind === "pinned") settings.pinnedSectionCollapsed = !settings.pinnedSectionCollapsed;
          if (kind === "notes") settings.notesSectionCollapsed = !settings.notesSectionCollapsed;
          saveUISettings_();
          applySectionCollapseUI_();
        };

        pinnedTitleEl?.addEventListener("click", () => toggleWith("pinned"));
        pinnedTitleEl?.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggleWith("pinned"); }
        });

        notesTitleEl?.addEventListener("click", () => toggleWith("notes"));
        notesTitleEl?.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggleWith("notes"); }
        });

        // Lista
        [pinnedListEl, notesListEl].forEach(root => {
          root.addEventListener("click", onListClick);
          root.addEventListener("keydown", onListKeydown);
          root.addEventListener("change", onListChange);

          root.addEventListener("dragstart", onDragStart);
          root.addEventListener("dragover", onDragOver);
          root.addEventListener("drop", onDrop);
          root.addEventListener("dragend", onDragEnd);

          if (supportsPointer) root.addEventListener("pointerdown", onHandlePointerDown);
        });

        // Modal nota
        noteCloseEl.addEventListener("click", () => closeNoteDialog_());
        noteDialogEl.addEventListener("click", (e) => {
          const rect = noteDialogEl.getBoundingClientRect();
          const inDialog = (
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top  && e.clientY <= rect.bottom
          );
          if (!inDialog) closeNoteDialog_();
        });

        noteEditorEl.addEventListener("input", () => {
          if (!activeNoteId) return;
          const note = getNoteById(activeNoteId);
          if (!note) return;

          note.text = noteEditorEl.value;
          note.updatedAt = Date.now();
          maybeAssignCategoryFromPrefix(note);

          updateNoteMeta_(note);
          syncNoteRowDataset_(note.id);
          saveDebounced();
          refreshPreviewDebounced();
        });

        noteEditorEl.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            e.preventDefault();
            closeNoteDialog_();
          }
        });

        /* ✅ Insertar fecha SOLO aaaa-mm-dd */
        noteInsertDateEl.addEventListener("click", () => {
          const stamp = formatDate_(Date.now());
          insertAtCursor_(noteEditorEl, stamp);
          noteEditorEl.dispatchEvent(new Event("input", { bubbles: true }));
          toast("Fecha insertada");
        });

        window.addEventListener("beforeunload", saveNow);
        window.addEventListener("pagehide", saveNow);
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "hidden") saveNow();
        });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && catDialogEl.open) closeCatDialog();
        });
      }

      function syncTopSelectTitles_() {
        try {
          const catText = catFilterEl?.options?.[catFilterEl.selectedIndex]?.textContent || "";
          const sortText = sortEl?.options?.[sortEl.selectedIndex]?.textContent || "";
          const catWrap = catFilterEl?.closest(".selectwrap");
          const sortWrap = sortEl?.closest(".selectwrap");
          if (catWrap) catWrap.title = `Categoría: ${catText || "—"}`;
          if (sortWrap) sortWrap.title = `Orden: ${sortText || "—"}`;
        } catch {}
      }

      function saveUISettings_() {
        try {
          localStorage.setItem(SETTINGS_KEY, JSON.stringify({
            sortMode: settings.sortMode,
            categoryFilter: settings.categoryFilter,
            theme: settings.theme,
            pinnedSectionCollapsed: !!settings.pinnedSectionCollapsed,
            notesSectionCollapsed: !!settings.notesSectionCollapsed
          }));
        } catch {}
      }

      function safeParse(json, fallback) { try { return JSON.parse(json); } catch { return fallback; } }
      function makeId() { return (window.crypto?.randomUUID) ? crypto.randomUUID() : String(Date.now()) + "_" + Math.random().toString(16).slice(2); }

      function norm(s) {
        return (s ?? "")
          .toString()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .toLowerCase();
      }

      function escapeHTML(s) {
        return (s ?? "").toString().replace(/[&<>"']/g, (ch) => ({
          "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"
        }[ch]));
      }

      function debounce(fn, ms) {
        let t = 0;
        return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
      }

      function buildNormMap(str) {
        let normStr = "";
        const map = [];
        for (let i = 0; i < str.length; i++) {
          const ch = str[i];
          const n = ch.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
          for (let j = 0; j < n.length; j++) {
            normStr += n[j];
            map.push(i);
          }
        }
        return { normStr, map };
      }

      function makeHighlightedHTML(text, terms, preview = false) {
        if (!text) return `<span class="placeholder">Toca para editar…</span>`;

        const cleanTerms = (terms || []).filter(Boolean);
        const baseText = preview
          ? (text ?? "").toString().replace(/\r/g, "").replace(/\n+/g, " ").replace(/\s+/g, " ").trim()
          : (text ?? "").toString();

        if (!cleanTerms.length) {
          const escaped = escapeHTML(baseText);
          return preview ? escaped : escaped.replace(/\n/g, "<br>");
        }

        const { normStr, map } = buildNormMap(baseText);
        const ranges = [];

        for (const term of cleanTerms) {
          let start = 0;
          while (true) {
            const idx = normStr.indexOf(term, start);
            if (idx === -1) break;
            ranges.push([idx, idx + term.length]);
            start = idx + term.length;
          }
        }

        if (!ranges.length) {
          const escaped = escapeHTML(baseText);
          return preview ? escaped : escaped.replace(/\n/g, "<br>");
        }

        ranges.sort((a, b) => a[0] - b[0] || a[1] - b[1]);

        const merged = [];
        for (const r of ranges) {
          if (!merged.length || r[0] > merged[merged.length - 1][1]) merged.push(r.slice());
          else merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], r[1]);
        }

        const origRanges = merged.map(([a, b]) => {
          const startOrig = map[a] ?? 0;
          const endOrig = (map[b - 1] ?? (baseText.length - 1)) + 1;
          return [startOrig, endOrig];
        });

        origRanges.sort((a, b) => a[0] - b[0]);
        const final = [];
        for (const r of origRanges) {
          if (!final.length || r[0] > final[final.length - 1][1]) final.push(r.slice());
          else final[final.length - 1][1] = Math.max(final[final.length - 1][1], r[1]);
        }

        let out = "";
        let last = 0;
        for (const [s, e] of final) {
          out += escapeHTML(baseText.slice(last, s));
          out += `<mark>${escapeHTML(baseText.slice(s, e))}</mark>`;
          last = e;
        }
        out += escapeHTML(baseText.slice(last));
        return preview ? out : out.replace(/\n/g, "<br>");
      }

      function cssEscape(s) {
        if (window.CSS && typeof CSS.escape === "function") return CSS.escape(s);
        return String(s).replace(/["\\]/g, "\\$&");
      }

      function pad2_(n){ return String(n).padStart(2,"0"); }

      /* ✅ Formatos fecha */
      function formatDateTime_(ms) {
        const d = new Date(ms);
        return `${d.getFullYear()}-${pad2_(d.getMonth()+1)}-${pad2_(d.getDate())} ${pad2_(d.getHours())}-${pad2_(d.getMinutes())}`;
      }
      function formatDate_(ms){
        const d = new Date(ms);
        return `${d.getFullYear()}-${pad2_(d.getMonth()+1)}-${pad2_(d.getDate())}`;
      }

      function insertAtCursor_(ta, text) {
        try {
          const start = ta.selectionStart ?? ta.value.length;
          const end = ta.selectionEnd ?? ta.value.length;
          const v = ta.value ?? "";
          ta.value = v.slice(0, start) + text + v.slice(end);
          const pos = start + text.length;
          ta.selectionStart = ta.selectionEnd = pos;
          ta.focus();
        } catch {
          ta.value = (ta.value || "") + text;
          ta.focus();
        }
      }

      function applySectionCollapseUI_(){
        try{
          pinnedSectionEl?.classList.toggle("collapsed", !!settings.pinnedSectionCollapsed);
          notesSectionEl?.classList.toggle("collapsed", !!settings.notesSectionCollapsed);

          if (pinnedChevronEl) pinnedChevronEl.innerHTML = settings.pinnedSectionCollapsed ? Icons.chevronRight : Icons.chevronDown;
          if (notesChevronEl) notesChevronEl.innerHTML = settings.notesSectionCollapsed ? Icons.chevronRight : Icons.chevronDown;

          pinnedTitleEl?.setAttribute("aria-expanded", String(!settings.pinnedSectionCollapsed));
          notesTitleEl?.setAttribute("aria-expanded", String(!settings.notesSectionCollapsed));
        } catch {}
      }

      /* =========================
         Categories
      ========================== */
      function ensureGeneralCategory() {
        if (!categories || !Array.isArray(categories)) categories = [];
        const hasGeneral = categories.some(c => String(c.id) === GENERAL_CATEGORY_ID);
        if (!hasGeneral) categories.unshift({ ...DEFAULT_GENERAL_CATEGORY });

        categories.forEach((c, i) => {
          if (!c || typeof c !== "object") return;
          c.id = String(c.id ?? makeId());
          c.name = String(c.name ?? "Categoría");
          c.color = CATEGORY_COLOR;
          c.order = Number.isFinite(Number(c.order)) ? Number(c.order) : i * 1000;
          c.collapsed = Boolean(c.collapsed ?? true);
        });

        const general = categories.find(c => c.id === GENERAL_CATEGORY_ID);
        if (general) {
          general.order = Math.min(general.order, -100000);
          general.color = CATEGORY_COLOR;
          if (typeof general.collapsed !== "boolean") general.collapsed = true;
        }

        categories = sortCategories(categories);
      }

      function sortCategories(list) {
        return (list || []).slice().sort((a, b) => {
          const ao = Number(a.order ?? 0), bo = Number(b.order ?? 0);
          if (ao !== bo) return ao - bo;
          return String(a.name || "").localeCompare(String(b.name || ""), "es", { sensitivity: "base" });
        });
      }

      function getCategoryById(id) {
        return categories.find(c => c.id === id) || null;
      }

      function sanitizeNotesCategoryIds() {
        const ids = new Set(categories.map(c => c.id));
        for (const n of notes) {
          if (!n.categoryId || !ids.has(n.categoryId)) n.categoryId = GENERAL_CATEGORY_ID;
        }
      }

      function renderCategoryFilter() {
        const current = settings.categoryFilter || "all";
        catFilterEl.innerHTML = "";

        const optAll = document.createElement("option");
        optAll.value = "all";
        optAll.textContent = "Todas";
        catFilterEl.appendChild(optAll);

        const sorted = sortCategories(categories);
        for (const c of sorted) {
          const opt = document.createElement("option");
          opt.value = c.id;
          opt.textContent = c.name;
          catFilterEl.appendChild(opt);
        }

        if (current !== "all" && !getCategoryById(current)) settings.categoryFilter = "all";
        catFilterEl.value = settings.categoryFilter || "all";
        syncTopSelectTitles_();
      }

      function openCatDialog({ focusNew } = {}) {
        renderCatManager();
        if (typeof catDialogEl.showModal === "function") catDialogEl.showModal();
        else catDialogEl.setAttribute("open", "open");

        if (focusNew) setTimeout(() => catNewNameEl.focus(), 0);
      }

      function closeCatDialog() {
        if (typeof catDialogEl.close === "function") catDialogEl.close();
        else catDialogEl.removeAttribute("open");
      }

      function renderCatManager() {
        ensureGeneralCategory();
        categories = sortCategories(categories);
        catTableEl.innerHTML = "";

        for (let i = 0; i < categories.length; i++) {
          const c = categories[i];
          const row = document.createElement("div");
          row.className = "cat-row";
          row.dataset.catId = c.id;

          const name = document.createElement("input");
          name.type = "text";
          name.value = c.name;
          name.placeholder = "Nombre";
          name.setAttribute("aria-label", "Nombre de categoría");
          name.disabled = (c.id === GENERAL_CATEGORY_ID);

          const up = document.createElement("button");
          up.className = "mini-btn";
          up.type = "button";
          up.innerHTML = "↑";
          up.title = "Subir";
          up.setAttribute("aria-label", "Subir");
          up.disabled = (i === 0);

          const down = document.createElement("button");
          down.className = "mini-btn";
          down.type = "button";
          down.innerHTML = "↓";
          down.title = "Bajar";
          down.setAttribute("aria-label", "Bajar");
          down.disabled = (i === categories.length - 1);

          const del = document.createElement("button");
          del.className = "btn btn-danger";
          del.type = "button";
          del.title = "Eliminar";
          del.setAttribute("aria-label", "Eliminar");
          del.innerHTML = `${Icons.trash}<span class="sr-only">Eliminar</span>`;
          del.disabled = (c.id === GENERAL_CATEGORY_ID);

          name.addEventListener("input", () => {
            c.name = name.value.trim() || c.name;
            saveDebounced();
            renderCategoryFilter();
            renderAllDebounced();
          });

          up.addEventListener("click", () => {
            swapCategoryOrder(i, i - 1);
            toast("Categoría movida");
          });

          down.addEventListener("click", () => {
            swapCategoryOrder(i, i + 1);
            toast("Categoría movida");
          });

          del.addEventListener("click", () => {
            if (!confirm(`¿Eliminar la categoría "${c.name}"?\nLas notas pasarán a "General".`)) return;
            deleteCategory(c.id);
          });

          row.appendChild(name);
          row.appendChild(up);
          row.appendChild(down);
          row.appendChild(del);

          catTableEl.appendChild(row);
        }
      }

      const renderAllDebounced = debounce(() => renderAll(), 120);

      function swapCategoryOrder(i, j) {
        categories = sortCategories(categories);
        if (j < 0 || j >= categories.length) return;
        const a = categories[i], b = categories[j];
        const tmp = a.order;
        a.order = b.order;
        b.order = tmp;

        renormalizeCategoryOrders();
        categories = sortCategories(categories);
        saveDebounced();
        renderCategoryFilter();
        renderCatManager();
        renderAll();
      }

      function renormalizeCategoryOrders() {
        categories = sortCategories(categories);
        for (let i = 0; i < categories.length; i++) {
          categories[i].order = i * 1000;
          categories[i].color = CATEGORY_COLOR;
        }
        const general = categories.find(c => c.id === GENERAL_CATEGORY_ID);
        if (general) general.order = -100000;
      }

      function deleteCategory(catId) {
        if (catId === GENERAL_CATEGORY_ID) return;

        for (const n of notes) {
          if (n.categoryId === catId) {
            n.categoryId = GENERAL_CATEGORY_ID;
            if (settings.sortMode === "manual") {
              n.order = lastOrder(n.pinned, GENERAL_CATEGORY_ID) + 1000;
            }
            n.updatedAt = Date.now();
          }
        }

        categories = categories.filter(c => c.id !== catId);
        ensureGeneralCategory();

        if (settings.sortMode === "manual") {
          renormalizeOrders(true, GENERAL_CATEGORY_ID);
          renormalizeOrders(false, GENERAL_CATEGORY_ID);
        }

        if (settings.categoryFilter === catId) settings.categoryFilter = "all";

        saveDebounced();
        renderCategoryFilter();
        renderCatManager();
        renderAll();
        toast("Categoría eliminada");
      }

      function addCategoryFromForm() {
        const name = (catNewNameEl.value || "").trim();
        if (!name) { toast("Escribe un nombre"); catNewNameEl.focus(); return; }

        const exists = categories.find(c => norm(c.name) === norm(name));
        if (exists) {
          toast("Ya existe una categoría con ese nombre");
          catNewNameEl.select();
          return;
        }

        const maxOrder = categories.reduce((m, c) => Math.max(m, Number(c.order ?? 0)), 0);
        const c = { id: makeId(), name, color: CATEGORY_COLOR, order: maxOrder + 1000, collapsed: true };
        categories.push(c);
        ensureGeneralCategory();

        catNewNameEl.value = "";

        saveDebounced();
        renderCategoryFilter();
        renderCatManager();
        renderAll();
        toast("Categoría creada");
      }

      /* =========================
         Serialize + Save
      ========================== */
      function serializeState() {
        return {
          v: 3,
          savedAt: Date.now(),
          notes,
          categories,
          settings: {
            sortMode: settings.sortMode,
            theme: settings.theme,
            categoryFilter: settings.categoryFilter,
            pinnedSectionCollapsed: !!settings.pinnedSectionCollapsed,
            notesSectionCollapsed: !!settings.notesSectionCollapsed
          }
        };
      }

      const saveDebounced = debounce(() => {
        lastSnapshot = makeSnapshot_(categories, notes);

        apiSaveAll_(serializeState())
          .catch(() => toast("No pude guardar (revisa API_URL /exec y deploy)"));
      }, 600);

      function saveNow() {
        try {
          lastSnapshot = makeSnapshot_(categories, notes);
          apiSaveAllFireAndForget_(serializeState());
        } catch {}
      }

      function makeSnapshot_(cats, nts) {
        try {
          return JSON.stringify({
            categories: Array.isArray(cats) ? cats : [],
            notes: Array.isArray(nts) ? nts : []
          });
        } catch {
          return String(Date.now());
        }
      }

      function startAutoSync() {
        setInterval(async () => {
          const noteOpen = !!(noteDialogEl?.open || noteDialogEl?.hasAttribute("open"));
          if (noteOpen || pointerDrag) return;

          try {
            const remote = await apiGetState_();
            const snap = makeSnapshot_(remote?.categories, remote?.notes);
            if (snap !== lastSnapshot) {
              notes = Array.isArray(remote?.notes) ? remote.notes : [];
              categories = Array.isArray(remote?.categories) ? remote.categories : [];

              ensureGeneralCategory();
              sanitizeNotesCategoryIds();

              renderCategoryFilter();
              renderAll();

              lastSnapshot = snap;
            }
          } catch {}
        }, AUTOSYNC_MS);
      }

      /* =========================
         Theme + Helpers
      ========================== */
      function applyTheme(theme) {
        let t = theme;
        if (theme === "auto") {
          t = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches ? "light" : "dark";
        }
        document.documentElement.setAttribute("data-theme", t);
      }

      function nextTheme(theme) { return theme === "auto" ? "dark" : theme === "dark" ? "light" : "auto"; }
      function themeLabel(theme) { return theme === "auto" ? "Auto" : theme === "dark" ? "Oscuro" : theme === "light" ? "Claro" : "Auto"; }

      function lastOrder(pinned, categoryId) {
        const group = notes
          .filter(n => !!n.pinned === !!pinned && (n.categoryId || GENERAL_CATEGORY_ID) === categoryId)
          .slice()
          .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
        return group.length ? (group[group.length - 1].order ?? 0) : -1000;
      }

      function createNote({ afterId = null, pinned = false, categoryId = GENERAL_CATEGORY_ID }) {
        const now = Date.now();

        const group = notes
          .filter(n => !!n.pinned === !!pinned && (n.categoryId || GENERAL_CATEGORY_ID) === categoryId)
          .slice()
          .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

        let order = group.length ? (group[group.length - 1].order ?? 0) + 1000 : 0;

        if (afterId) {
          const idx = group.findIndex(n => n.id === afterId);
          if (idx !== -1) {
            const after = group[idx];
            const next = group[idx + 1];
            order = next ? (Number(after.order ?? 0) + Number(next.order ?? 0)) / 2 : Number(after.order ?? 0) + 1000;
          }
        }

        return {
          id: makeId(),
          text: "",
          createdAt: now,
          updatedAt: now,
          pinned: !!pinned,
          order,
          categoryId
        };
      }

      function renormalizeOrders(pinned, categoryId) {
        const group = notes
          .filter(n => !!n.pinned === !!pinned && (n.categoryId || GENERAL_CATEGORY_ID) === categoryId)
          .slice()
          .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

        for (let i = 0; i < group.length; i++) group[i].order = i * 1000;
      }

      function getNoteById(id) { return notes.find(n => n.id === id) || null; }

      function getSorter() {
        const mode = settings.sortMode;
        const sorters = {
          manual: (a, b) => (a.order ?? 0) - (b.order ?? 0),
          updated_desc: (a, b) => (b.updatedAt ?? 0) - (a.updatedAt ?? 0),
          created_desc: (a, b) => (b.createdAt ?? 0) - (a.createdAt ?? 0),
          alpha_asc: (a, b) => (a.text || "").localeCompare((b.text || ""), "es", { sensitivity: "base" })
        };
        return sorters[mode] || sorters.manual;
      }

      function groupNotesByCategory(list) {
        const map = new Map();
        for (const n of list) {
          const catId = n.categoryId || GENERAL_CATEGORY_ID;
          if (!map.has(catId)) map.set(catId, []);
          map.get(catId).push(n);
        }
        return map;
      }

      function getSortedNotesByCategory() {
        const sorter = getSorter();
        const pinned = notes.filter(n => !!n.pinned);
        const normal = notes.filter(n => !n.pinned);

        const pinnedByCat = groupNotesByCategory(pinned);
        const normalByCat = groupNotesByCategory(normal);

        for (const [k, arr] of pinnedByCat) pinnedByCat.set(k, arr.slice().sort(sorter));
        for (const [k, arr] of normalByCat) normalByCat.set(k, arr.slice().sort(sorter));

        return { pinnedByCat, normalByCat };
      }

      function currentTerms() {
        return norm(searchEl.value).split(/\s+/).filter(Boolean);
      }

      function pinHTML(pinned) {
        const label = pinned ? "Soltar" : "Fijar";
        const icon = pinned ? Icons.unpin : Icons.pin;
        return `${icon}<span class="sr-only">${label}</span>`;
      }

      function buildCategorySelectWrap(note) {
        const wrap = document.createElement("div");
        wrap.className = "selectwrap note-select";
        wrap.innerHTML = `
          ${Icons.tag}
          <select data-role="catSelect" aria-label="Cambiar categoría"></select>
        `;

        const sel = wrap.querySelector('select[data-role="catSelect"]');

        const sorted = sortCategories(categories);
        for (const c of sorted) {
          const opt = document.createElement("option");
          opt.value = c.id;
          opt.textContent = c.name;
          sel.appendChild(opt);
        }
        sel.value = note.categoryId || GENERAL_CATEGORY_ID;

        wrap.title = `Categoría: ${sel.options[sel.selectedIndex]?.textContent || "—"}`;
        return wrap;
      }

      function buildNoteEl(note) {
        const el = document.createElement("article");
        el.className = "note";
        el.dataset.id = note.id;
        el.dataset.norm = norm(note.text);
        el.dataset.categoryId = note.categoryId || GENERAL_CATEGORY_ID;
        el.dataset.pinned = String(!!note.pinned);
        el.draggable = false;

        const drag = document.createElement("button");
        drag.className = "drag-handle";
        drag.type = "button";
        drag.title = "Arrastrar para reordenar (modo manual). En móvil: mantén presionado y arrastra.";
        drag.setAttribute("aria-label", "Arrastrar para reordenar");
        drag.textContent = "≡";
        drag.draggable = true;

        const content = document.createElement("div");
        content.className = "content";

        const view = document.createElement("div");
        view.className = "note-view";
        view.tabIndex = 0;
        view.setAttribute("role", "button");
        view.setAttribute("aria-label", "Abrir editor");
        view.innerHTML = makeHighlightedHTML(note.text, currentTerms(), true);

        content.appendChild(view);

        const actions = document.createElement("div");
        actions.className = "actions";

        const catSelWrap = buildCategorySelectWrap(note);

        const pinBtn = document.createElement("button");
        pinBtn.className = "btn btn-pin";
        pinBtn.type = "button";
        pinBtn.dataset.action = "pin";
        pinBtn.title = note.pinned ? "Soltar" : "Fijar";
        pinBtn.setAttribute("aria-label", note.pinned ? "Soltar" : "Fijar");
        pinBtn.innerHTML = pinHTML(note.pinned);

        const cpBtn = document.createElement("button");
        cpBtn.className = "btn";
        cpBtn.type = "button";
        cpBtn.dataset.action = "copyPaste";
        setCopyPasteUI(cpBtn, note.text);

        const clearBtn = document.createElement("button");
        clearBtn.className = "btn btn-ghost";
        clearBtn.type = "button";
        clearBtn.dataset.action = "clear";
        clearBtn.title = "Limpiar";
        clearBtn.setAttribute("aria-label", "Limpiar");
        clearBtn.innerHTML = `${Icons.clear}<span class="sr-only">Limpiar</span>`;

        const delBtn = document.createElement("button");
        delBtn.className = "btn btn-danger";
        delBtn.type = "button";
        delBtn.dataset.action = "delete";
        delBtn.title = "Eliminar";
        delBtn.setAttribute("aria-label", "Eliminar");
        delBtn.innerHTML = `${Icons.trash}<span class="sr-only">Eliminar</span>`;

        actions.appendChild(catSelWrap);
        actions.appendChild(pinBtn);
        actions.appendChild(cpBtn);
        actions.appendChild(clearBtn);
        actions.appendChild(delBtn);

        el.appendChild(drag);
        el.appendChild(content);
        el.appendChild(actions);

        return el;
      }

      function buildCatGroupEl({ cat, pinned, notesInCat, showEmpty }) {
        const group = document.createElement("div");
        group.className = "cat-group" + (cat.collapsed ? " collapsed" : "");
        group.dataset.catId = cat.id;
        group.dataset.pinned = String(!!pinned);

        const head = document.createElement("div");
        head.className = "cat-head";

        const left = document.createElement("div");
        left.className = "cat-left";

        const toggle = document.createElement("button");
        toggle.className = "cat-toggle";
        toggle.type = "button";
        toggle.dataset.action = "toggleCat";
        toggle.dataset.catId = cat.id;
        toggle.dataset.pinned = String(!!pinned);
        toggle.title = "Contraer/Expandir";
        toggle.setAttribute("aria-label", "Contraer/Expandir");
        toggle.setAttribute("aria-expanded", String(!cat.collapsed));
        toggle.innerHTML = cat.collapsed ? Icons.chevronRight : Icons.chevronDown;

        const pill = document.createElement("span");
        pill.className = "cat-pill";
        pill.title = "Categoría";
        pill.innerHTML = `
          <span class="cat-dot"></span>
          <span class="cat-name">${escapeHTML(cat.name)}</span>
          <span class="cat-count" data-role="catCount">${notesInCat.length}</span>
        `;

        left.appendChild(toggle);
        left.appendChild(pill);

        const right = document.createElement("div");
        right.className = "cat-right";

        if (!pinned) {
          const add = document.createElement("button");
          add.className = "btn btn-ghost";
          add.type = "button";
          add.dataset.action = "newInCat";
          add.dataset.catId = cat.id;
          add.title = "Nueva nota en esta categoría";
          add.setAttribute("aria-label", "Nueva nota en esta categoría");
          add.innerHTML = `${Icons.plus}<span class="sr-only">Nueva</span>`;
          right.appendChild(add);
        }

        head.appendChild(left);
        head.appendChild(right);

        const list = document.createElement("div");
        list.className = "cat-list";
        list.setAttribute("role", "list");
        list.dataset.role = "catList";
        list.dataset.categoryId = cat.id;
        list.dataset.pinned = String(!!pinned);

        if (notesInCat.length) {
          const frag = document.createDocumentFragment();
          for (const n of notesInCat) frag.appendChild(buildNoteEl(n));
          list.appendChild(frag);
        } else if (showEmpty) {
          const empty = document.createElement("div");
          empty.className = "cat-empty";
          empty.textContent = "Sin notas en esta categoría";
          list.appendChild(empty);
        }

        group.appendChild(head);
        group.appendChild(list);
        return group;
      }

      function renderAll() {
        ensureGeneralCategory();
        renderCategoryFilter();

        const { pinnedByCat, normalByCat } = getSortedNotesByCategory();
        const sortedCats = sortCategories(categories);

        const filter = settings.categoryFilter || "all";
        const terms = currentTerms();
        const isSearching = terms.length > 0;

        pinnedListEl.innerHTML = "";
        notesListEl.innerHTML = "";

        let pinnedHasAnything = false;
        for (const cat of sortedCats) {
          if (filter !== "all" && cat.id !== filter) continue;
          const list = pinnedByCat.get(cat.id) || [];
          if (!list.length) continue;

          pinnedHasAnything = true;
          pinnedListEl.appendChild(buildCatGroupEl({
            cat,
            pinned: true,
            notesInCat: list,
            showEmpty: false
          }));
        }
        pinnedSectionEl.hidden = !pinnedHasAnything;

        for (const cat of sortedCats) {
          if (filter !== "all" && cat.id !== filter) continue;

          const list = normalByCat.get(cat.id) || [];
          const showEmpty = (!isSearching);

          notesListEl.appendChild(buildCatGroupEl({
            cat,
            pinned: false,
            notesInCat: list,
            showEmpty
          }));
        }

        applySearchAndHighlights();
        applySectionCollapseUI_();
      }

      function applySearchAndHighlights() {
        const terms = currentTerms();
        const filter = settings.categoryFilter || "all";
        const isSearching = terms.length > 0;

        const total = (filter === "all")
          ? notes.length
          : notes.filter(n => (n.categoryId || GENERAL_CATEGORY_ID) === filter).length;

        let visible = 0;

        const roots = [pinnedListEl, notesListEl];
        for (const root of roots) {
          const items = root.querySelectorAll(".note");
          items.forEach(el => {
            const id = el.dataset.id;
            const note = getNoteById(id);
            if (!note) return;

            const t = el.dataset.norm || "";
            const matchText = terms.every(term => t.includes(term));

            const catId = note.categoryId || GENERAL_CATEGORY_ID;
            const matchCat = (filter === "all") ? true : (catId === filter);

            const match = matchText && matchCat;
            el.hidden = !match;
            if (match) visible++;

            const view = el.querySelector(".note-view");
            if (view) view.innerHTML = makeHighlightedHTML(note.text, terms, true);

            const cpBtn = el.querySelector('[data-action="copyPaste"]');
            if (cpBtn) setCopyPasteUI(cpBtn, note.text);

            const pinBtn = el.querySelector('[data-action="pin"]');
            if (pinBtn) {
              pinBtn.innerHTML = pinHTML(note.pinned);
              pinBtn.title = note.pinned ? "Soltar" : "Fijar";
              pinBtn.setAttribute("aria-label", note.pinned ? "Soltar" : "Fijar");
            }

            const sel = el.querySelector('select[data-role="catSelect"]');
            if (sel) {
              sel.value = catId;
              const wrap = sel.closest(".selectwrap");
              if (wrap) wrap.title = `Categoría: ${sel.options[sel.selectedIndex]?.textContent || "—"}`;
            }

            el.dataset.categoryId = catId;
            el.dataset.pinned = String(!!note.pinned);
          });
        }

        for (const root of roots) {
          const groups = root.querySelectorAll(".cat-group");
          groups.forEach(group => {
            const list = group.querySelector(".cat-list");
            const countEl2 = group.querySelector('[data-role="catCount"]');

            const visibleNotes = list ? list.querySelectorAll(".note:not([hidden])").length : 0;
            if (countEl2) countEl2.textContent = String(visibleNotes);

            if (isSearching) group.hidden = (visibleNotes === 0);
            else group.hidden = false;
          });
        }

        const anyPinnedVisible = pinnedListEl.querySelector(".note:not([hidden])");
        pinnedSectionEl.hidden = !anyPinnedVisible;

        const anyNormalVisible = notesListEl.querySelector(".note:not([hidden])");
        emptyEl.hidden = (anyPinnedVisible || anyNormalVisible);

        updateCount(visible, total);

        const dragEnabled = (settings.sortMode === "manual");
        document.querySelectorAll(".drag-handle").forEach(b => {
          b.style.opacity = dragEnabled ? "1" : ".35";
          b.title = dragEnabled
            ? "Arrastrar para reordenar (modo manual). En móvil: mantén presionado y arrastra."
            : "Reordenar solo disponible en modo Manual";

          b.draggable = dragEnabled && !isCoarsePointer;
        });
      }

      function updateCount(visible, total) {
        countEl.textContent = `${visible} de ${total}`;
      }

      /* =========================
         Modal nota (edición)
      ========================== */
      function openNoteDialog_(id) {
        const note = getNoteById(id);
        if (!note) return;

        activeNoteId = id;

        noteEditorEl.value = note.text || "";
        updateNoteMeta_(note);

        if (typeof noteDialogEl.showModal === "function") noteDialogEl.showModal();
        else noteDialogEl.setAttribute("open", "open");

        setTimeout(() => {
          noteEditorEl.focus();
          const len = noteEditorEl.value.length;
          noteEditorEl.selectionStart = noteEditorEl.selectionEnd = len;
        }, 0);
      }

      function closeNoteDialog_() {
        activeNoteId = null;
        if (typeof noteDialogEl.close === "function") noteDialogEl.close();
        else noteDialogEl.removeAttribute("open");
      }

      /* ✅ Formato requerido: c:aaaa-mm-dd hh-mm - m:aaaa-mm-dd hh-mm */
      function updateNoteMeta_(note) {
        const created = formatDateTime_(note.createdAt || Date.now());
        const updated = formatDateTime_(note.updatedAt || note.createdAt || Date.now());
        noteMetaEl.textContent = `c:${created} - m:${updated}`;
      }

      function syncNoteRowDataset_(noteId) {
        const el = document.querySelector(\`.note[data-id="\${cssEscape(noteId)}"]\`);
        const note = getNoteById(noteId);
        if (!el || !note) return;
        el.dataset.norm = norm(note.text);
      }

      function focusNote(id) {
        const safeId = cssEscape(id);
        const noteEl = document.querySelector(\`.note[data-id="\${safeId}"]\`);
        if (noteEl) noteEl.scrollIntoView({ block: "nearest", behavior: "smooth" });
        openNoteDialog_(id);
      }

      /* =========================
         List events
      ========================== */
      function findNoteEl(target) { return target.closest(".note"); }

      function onListClick(e) {
        const catBtn = e.target.closest("[data-action]");
        if (catBtn && catBtn.dataset.action === "toggleCat") {
          const catId = catBtn.dataset.catId;
          const c = getCategoryById(catId);
          if (!c) return;

          c.collapsed = !c.collapsed;
          saveDebounced();

          const group = catBtn.closest(".cat-group");
          if (group) {
            group.classList.toggle("collapsed", c.collapsed);
            catBtn.innerHTML = c.collapsed ? Icons.chevronRight : Icons.chevronDown;
            catBtn.setAttribute("aria-expanded", String(!c.collapsed));
          }
          return;
        }

        if (catBtn && catBtn.dataset.action === "newInCat") {
          const catId = catBtn.dataset.catId || GENERAL_CATEGORY_ID;
          const n = createNote({ afterId: null, pinned: false, categoryId: catId });
          notes.push(n);
          if (settings.sortMode === "manual") renormalizeOrders(false, catId);
          saveDebounced();
          renderAll();
          focusNote(n.id);
          toast("Nota creada");
          return;
        }

        const noteEl = findNoteEl(e.target);
        if (!noteEl) return;

        const id = noteEl.dataset.id;
        const note = getNoteById(id);
        if (!note) return;

        if (e.target.closest(".note-view")) {
          openNoteDialog_(note.id);
          return;
        }

        const actionBtn = e.target.closest("[data-action]");
        if (!actionBtn) return;

        const action = actionBtn.dataset.action;

        if (action === "pin") {
          const prevPinned = !!note.pinned;
          note.pinned = !note.pinned;
          note.updatedAt = Date.now();

          if (settings.sortMode === "manual") {
            const catId = note.categoryId || GENERAL_CATEGORY_ID;
            note.order = lastOrder(note.pinned, catId) + 1000;
            renormalizeOrders(prevPinned, catId);
            renormalizeOrders(note.pinned, catId);
          }

          saveDebounced();
          renderAll();
          toast(note.pinned ? "Nota fijada 📌" : "Nota liberada");
          return;
        }

        if (action === "copyPaste") {
          (async () => {
            if (note.text && note.text.length > 0) {
              const ok = await copyToClipboard(note.text);
              toast(ok ? "Copiado ✅" : "No pude copiar ❌");
            } else {
              const clip = await readFromClipboard();
              note.text = clip;
              note.updatedAt = Date.now();
              saveDebounced();

              syncNoteRowDataset_(note.id);
              if (activeNoteId === note.id) {
                noteEditorEl.value = note.text;
                updateNoteMeta_(note);
              }
              applySearchAndHighlights();
              toast("Pegado ✅");
            }
          })();
          return;
        }

        if (action === "clear") {
          note.text = "";
          note.updatedAt = Date.now();
          saveDebounced();

          syncNoteRowDataset_(note.id);
          if (activeNoteId === note.id) {
            noteEditorEl.value = "";
            updateNoteMeta_(note);
          }
          applySearchAndHighlights();
          toast("Nota limpiada");
          return;
        }

        if (action === "delete") {
          deleteNote(note.id);
          return;
        }
      }

      function onListKeydown(e) {
        const noteEl = findNoteEl(e.target);
        if (!noteEl) return;

        if (e.target.classList.contains("note-view") && (e.key === "Enter" || e.key === " ")) {
          e.preventDefault();
          openNoteDialog_(noteEl.dataset.id);
          return;
        }
      }

      function onListChange(e) {
        const sel = e.target.closest('select[data-role="catSelect"]');
        if (!sel) return;

        const noteEl = findNoteEl(sel);
        if (!noteEl) return;

        const id = noteEl.dataset.id;
        const note = getNoteById(id);
        if (!note) return;

        const oldCat = note.categoryId || GENERAL_CATEGORY_ID;
        const newCat = sel.value || GENERAL_CATEGORY_ID;
        if (newCat === oldCat) return;

        note.categoryId = newCat;
        note.updatedAt = Date.now();

        if (settings.sortMode === "manual") {
          note.order = lastOrder(note.pinned, newCat) + 1000;
          renormalizeOrders(note.pinned, oldCat);
          renormalizeOrders(note.pinned, newCat);
        }

        const wrap = sel.closest(".selectwrap");
        if (wrap) wrap.title = `Categoría: ${sel.options[sel.selectedIndex]?.textContent || "—"}`;

        saveDebounced();
        renderAll();
        toast("Categoría cambiada");
      }

      function maybeAssignCategoryFromPrefix(note) {
        const txt = String(note.text || "");
        const m = txt.match(/^\s*@([^\s\r\n\t]+)\s+/);
        if (!m) return;

        const token = m[1];
        const found = categories.find(c => norm(c.name) === norm(token));
        if (!found) return;

        const oldCat = note.categoryId || GENERAL_CATEGORY_ID;
        const newCat = found.id;

        if (newCat !== oldCat) {
          note.categoryId = newCat;
          if (settings.sortMode === "manual") {
            note.order = lastOrder(note.pinned, newCat) + 1000;
            renormalizeOrders(note.pinned, oldCat);
            renormalizeOrders(note.pinned, newCat);
          }
        }

        note.text = txt.replace(/^\s*@([^\s\r\n\t]+)\s+/, "");
        if (activeNoteId === note.id) noteEditorEl.value = note.text;
      }

      async function copyToClipboard(text) {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch {
          try {
            const ta = document.createElement("textarea");
            ta.value = text;
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            document.body.appendChild(ta);
            ta.select();
            const ok = document.execCommand("copy");
            document.body.removeChild(ta);
            return ok;
          } catch {
            return false;
          }
        }
      }

      async function readFromClipboard() {
        try {
          return await navigator.clipboard.readText();
        } catch {
          return prompt("No pude leer el portapapeles automáticamente. Pega aquí el texto:") ?? "";
        }
      }

      function setCopyPasteUI(btn, text) {
        const hasText = (text ?? "").length > 0;
        btn.classList.remove("btn-copy", "btn-paste");

        if (hasText) {
          btn.classList.add("btn-copy");
          btn.title = "Copiar";
          btn.setAttribute("aria-label", "Copiar");
          btn.innerHTML = `${Icons.copy}<span class="sr-only">Copiar</span>`;
        } else {
          btn.classList.add("btn-paste");
          btn.title = "Pegar";
          btn.setAttribute("aria-label", "Pegar");
          btn.innerHTML = `${Icons.paste}<span class="sr-only">Pegar</span>`;
        }
      }

      function deleteNote(id) {
        const idx = notes.findIndex(n => n.id === id);
        if (idx === -1) return;

        const [removed] = notes.splice(idx, 1);
        undoState = { note: removed, index: idx };

        if (activeNoteId === id) closeNoteDialog_();

        saveDebounced();
        renderAll();

        toastWithAction("Nota eliminada", "Deshacer", () => {
          if (!undoState) return;
          notes.splice(undoState.index, 0, undoState.note);

          if (settings.sortMode === "manual") {
            const catId = undoState.note.categoryId || GENERAL_CATEGORY_ID;
            renormalizeOrders(!!undoState.note.pinned, catId);
          }

          saveDebounced();
          renderAll();
          undoState = null;
          toast("Restaurada ✅");
        }, 4500);
      }

      /* =========================
         Export / Import
      ========================== */
      function exportJSON() {
        const payload = {
          v: 3,
          exportedAt: Date.now(),
          notes,
          categories,
          settings: {
            sortMode: settings.sortMode,
            theme: settings.theme,
            categoryFilter: settings.categoryFilter,
            pinnedSectionCollapsed: !!settings.pinnedSectionCollapsed,
            notesSectionCollapsed: !!settings.notesSectionCollapsed
          }
        };
        downloadFile("notas.json", JSON.stringify(payload, null, 2), "application/json");
        toast("Exportado JSON ✅");
      }

      function exportTXT() {
        const sortedCats = sortCategories(categories);
        const { pinnedByCat, normalByCat } = getSortedNotesByCategory();

        const blocks = [];

        blocks.push("=== FIJADAS ===");
        for (const cat of sortedCats) {
          const arr = pinnedByCat.get(cat.id) || [];
          if (!arr.length) continue;

          blocks.push(`=== CATEGORIA: ${cat.name} ===`);
          blocks.push(arr.map(n => n.text || "").join("\n\n---\n\n"));
          blocks.push("");
        }

        blocks.push("=== NOTAS ===");
        for (const cat of sortedCats) {
          const arr = normalByCat.get(cat.id) || [];
          if (!arr.length) continue;

          blocks.push(`=== CATEGORIA: ${cat.name} ===`);
          blocks.push(arr.map(n => n.text || "").join("\n\n---\n\n"));
          blocks.push("");
        }

        downloadFile("notas.txt", blocks.join("\n"), "text/plain;charset=utf-8");
        toast("Exportado TXT ✅");
      }

      async function importFile(file) {
        const name = (file.name || "").toLowerCase();
        const text = await file.text();

        if (name.endsWith(".json")) {
          const data = safeParse(text, null);
          if (!data) { toast("JSON inválido ❌"); return; }

          const incomingCats = Array.isArray(data.categories) ? data.categories : [];
          const incomingNotes = Array.isArray(data.notes) ? data.notes : [];

          ensureGeneralCategory();
          const byNormName = new Map(categories.map(c => [norm(c.name), c]));
          const idMap = new Map();

          for (const ic of incomingCats) {
            if (!ic || !ic.name) continue;
            const k = norm(ic.name);
            if (byNormName.has(k)) {
              idMap.set(String(ic.id), byNormName.get(k).id);
              continue;
            }
            const newId = makeId();
            categories.push({
              id: newId,
              name: String(ic.name),
              color: CATEGORY_COLOR,
              order: categories.reduce((m, c) => Math.max(m, Number(c.order ?? 0)), 0) + 1000,
              collapsed: true
            });
            byNormName.set(k, categories[categories.length - 1]);
            idMap.set(String(ic.id), newId);
          }

          ensureGeneralCategory();
          categories = sortCategories(categories);

          const catIds = new Set(categories.map(c => c.id));
          const existing = new Set(notes.map(n => n.id));

          for (const n of incomingNotes) {
            const nn = { ...n };
            if (!nn.id || existing.has(nn.id)) nn.id = makeId();
            existing.add(nn.id);

            if (idMap.has(String(nn.categoryId))) nn.categoryId = idMap.get(String(nn.categoryId));
            if (!catIds.has(nn.categoryId)) nn.categoryId = GENERAL_CATEGORY_ID;

            const now = Date.now();
            nn.createdAt = Number(nn.createdAt || now);
            nn.updatedAt = Number(nn.updatedAt || nn.createdAt);
            nn.pinned = !!nn.pinned;
            nn.order = Number.isFinite(Number(nn.order)) ? Number(nn.order) : (notes.length * 1000);

            notes.push(nn);
          }

          if (settings.sortMode === "manual") {
            for (const catId of catIds) {
              renormalizeOrders(true, catId);
              renormalizeOrders(false, catId);
            }
          }

          saveDebounced();
          renderCategoryFilter();
          renderAll();
          toast(`Importadas ${incomingNotes.length} notas ✅`);
          return;
        }

        const cleaned = text
          .replace(/\r/g, "")
          .replace(/^===\s*FIJADAS\s*===\s*\n?/im, "")
          .replace(/^===\s*NOTAS\s*===\s*\n?/im, "")
          .replace(/^===\s*CATEGORIA:\s*.*?===\s*\n?/gim, "")
          .split(/\n\s*---\s*\n/g)
          .join("\n\n");

        const blocks = cleaned
          .split(/\n\s*\n+/)
          .map(s => s.trim())
          .filter(Boolean);

        if (!blocks.length) { toast("TXT vacío"); return; }

        const now = Date.now();
        const created = blocks.map((b, i) => ({
          id: makeId(),
          text: b,
          createdAt: now,
          updatedAt: now,
          pinned: false,
          categoryId: GENERAL_CATEGORY_ID,
          order: i * 1000
        }));

        notes.push(...created);
        if (settings.sortMode === "manual") renormalizeOrders(false, GENERAL_CATEGORY_ID);

        saveDebounced();
        renderAll();
        toast(`Importadas ${created.length} notas ✅`);
      }

      function downloadFile(filename, content, mime) {
        const blob = new Blob([content], { type: mime });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      /* =========================
         Toast
      ========================== */
      function toast(message, ms = 1400) {
        toastEl.textContent = message;
        toastEl.classList.add("show");
        clearTimeout(toast._t);
        toast._t = setTimeout(() => toastEl.classList.remove("show"), ms);
      }

      function toastWithAction(message, actionText, onAction, ms = 3000) {
        toastEl.innerHTML = "";
        const span = document.createElement("span");
        span.textContent = message;

        const btn = document.createElement("button");
        btn.className = "toast-btn";
        btn.type = "button";
        btn.textContent = actionText;

        btn.addEventListener("click", () => {
          try { onAction?.(); } finally { toastEl.classList.remove("show"); }
        }, { once: true });

        toastEl.appendChild(span);
        toastEl.appendChild(btn);

        toastEl.classList.add("show");
        clearTimeout(toast._t);
        toast._t = setTimeout(() => toastEl.classList.remove("show"), ms);
      }

      /* =========================
         Drag & Drop (manual)
      ========================== */
      function canDrag() { return settings.sortMode === "manual"; }

      function getNoteContainerFromEventTarget(target) {
        return target.closest('.cat-list[data-role="catList"]');
      }

      function onDragStart(e) {
        if (!canDrag()) { e.preventDefault(); return; }
        if (isCoarsePointer) { e.preventDefault(); return; }

        const handle = e.target.closest(".drag-handle");
        if (!handle) { e.preventDefault(); return; }

        const noteEl = handle.closest(".note");
        if (!noteEl) { e.preventDefault(); return; }

        const id = noteEl.dataset.id;
        const note = getNoteById(id);
        if (!note) { e.preventDefault(); return; }

        const container = noteEl.closest(".cat-list");
        if (!container) { e.preventDefault(); return; }

        dragId = id;
        dragCtx = { id, pinned: !!note.pinned, categoryId: note.categoryId || GENERAL_CATEGORY_ID };

        noteEl.classList.add("dragging");

        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", dragId);

        try { e.dataTransfer.setDragImage(noteEl, 18, 18); } catch {}
      }

      function onDragOver(e) {
        if (!canDrag() || !dragId || !dragCtx) return;

        const container = getNoteContainerFromEventTarget(e.target);
        if (!container) return;

        const pinned = container.dataset.pinned === "true";
        const catId = container.dataset.categoryId;

        if (pinned !== dragCtx.pinned) return;
        if (catId !== dragCtx.categoryId) return;

        e.preventDefault();

        const draggingEl = document.querySelector(`.note[data-id="${cssEscape(dragId)}"]`);
        if (!draggingEl) return;

        const afterEl = getDragAfterElement(container, e.clientY);
        if (afterEl == null) container.appendChild(draggingEl);
        else container.insertBefore(draggingEl, afterEl);
      }

      function onDrop(e) {
        if (!canDrag() || !dragId || !dragCtx) return;

        const container = getNoteContainerFromEventTarget(e.target);
        if (!container) return;

        const pinned = container.dataset.pinned === "true";
        const catId = container.dataset.categoryId;

        if (pinned !== dragCtx.pinned) return;
        if (catId !== dragCtx.categoryId) return;

        e.preventDefault();

        saveManualOrderFromContainer(container);

        dragId = null;
        dragCtx = null;
        renderAll();
        toast("Orden guardado");
      }

      function onDragEnd() {
        document.querySelectorAll(".note.dragging").forEach(el => el.classList.remove("dragging"));
        dragId = null;
        dragCtx = null;
      }

      function getDragAfterElement(container, y) {
        const els = [...container.querySelectorAll(".note:not(.dragging):not(.placeholder)")];
        let closest = { offset: Number.NEGATIVE_INFINITY, element: null };

        for (const el of els) {
          const box = el.getBoundingClientRect();
          const offset = y - (box.top + box.height / 2);
          if (offset < 0 && offset > closest.offset) closest = { offset, element: el };
        }
        return closest.element;
      }

      function saveManualOrderFromContainer(container) {
        const pinned = container.dataset.pinned === "true";
        const categoryId = container.dataset.categoryId || GENERAL_CATEGORY_ID;

        const ids = [...container.querySelectorAll(".note:not(.placeholder)")].map(el => el.dataset.id);
        const groupNotes = notes.filter(n => !!n.pinned === pinned && (n.categoryId || GENERAL_CATEGORY_ID) === categoryId);

        const byId = new Map(groupNotes.map(n => [n.id, n]));
        for (let i = 0; i < ids.length; i++) {
          const n = byId.get(ids[i]);
          if (n) n.order = i * 1000;
        }

        saveDebounced();
      }

      /* ✅ Móvil: drag táctil */
      function onHandlePointerDown(e) {
        if (!isCoarsePointer) return;
        if (!canDrag()) return;
        if (pointerDrag) return;

        const handle = e.target.closest(".drag-handle");
        if (!handle) return;

        const noteEl = handle.closest(".note");
        if (!noteEl) return;

        const container = noteEl.closest(".cat-list");
        if (!container) return;

        const startX = e.clientX;
        const startY = e.clientY;
        const pointerId = e.pointerId;

        pendingPress = {
          pointerId,
          startX, startY,
          lastX: startX, lastY: startY,
          noteEl, container
        };

        const t = setTimeout(() => {
          if (!pendingPress || pendingPress.pointerId !== pointerId) return;
          beginPointerDrag(pendingPress.noteEl, pendingPress.container, pointerId, pendingPress.lastX, pendingPress.lastY);
          pendingPress = null;
        }, 180);

        pendingPress.timer = t;

        const onMove = (ev) => {
          if (!pendingPress || ev.pointerId !== pointerId) return;
          pendingPress.lastX = ev.clientX;
          pendingPress.lastY = ev.clientY;

          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          if (Math.hypot(dx, dy) > 10) {
            clearTimeout(t);
            cleanup();
          }
        };

        const onUp = (ev) => {
          if (!pendingPress || ev.pointerId !== pointerId) return;
          clearTimeout(t);
          cleanup();
        };

        const cleanup = () => {
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", onUp);
          window.removeEventListener("pointercancel", onUp);
          pendingPress = null;
        };

        window.addEventListener("pointermove", onMove, { passive: true });
        window.addEventListener("pointerup", onUp, { passive: true });
        window.addEventListener("pointercancel", onUp, { passive: true });
      }

      function beginPointerDrag(noteEl, container, pointerId, clientX, clientY) {
        const rect = noteEl.getBoundingClientRect();

        const placeholder = document.createElement("div");
        placeholder.className = "note placeholder";
        placeholder.style.height = rect.height + "px";

        container.insertBefore(placeholder, noteEl);

        noteEl.classList.add("dragging", "dragging-touch");
        noteEl.style.position = "fixed";
        noteEl.style.zIndex = "9999";
        noteEl.style.width = rect.width + "px";
        noteEl.style.left = rect.left + "px";
        noteEl.style.top = rect.top + "px";

        document.body.appendChild(noteEl);
        document.body.classList.add("dragging-no-select");

        const offsetX = clientX - rect.left;
        const offsetY = clientY - rect.top;

        pointerDrag = { pointerId, noteEl, container, placeholder, offsetX, offsetY };

        const onMove = (e) => {
          if (!pointerDrag) return;
          if (e.pointerId !== pointerDrag.pointerId) return;

          e.preventDefault();

          const x = e.clientX;
          const y = e.clientY;

          pointerDrag.noteEl.style.left = (x - pointerDrag.offsetX) + "px";
          pointerDrag.noteEl.style.top  = (y - pointerDrag.offsetY) + "px";

          autoScrollWindow(y);

          const afterEl = getDragAfterElement(pointerDrag.container, y);
          if (afterEl == null) pointerDrag.container.appendChild(pointerDrag.placeholder);
          else pointerDrag.container.insertBefore(pointerDrag.placeholder, afterEl);
        };

        const onEnd = (e) => {
          if (!pointerDrag) return;
          if (e.pointerId !== pointerDrag.pointerId) return;

          e.preventDefault();

          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", onEnd);
          window.removeEventListener("pointercancel", onEnd);

          pointerDrag.container.insertBefore(pointerDrag.noteEl, pointerDrag.placeholder);
          pointerDrag.placeholder.remove();

          pointerDrag.noteEl.classList.remove("dragging", "dragging-touch");
          pointerDrag.noteEl.style.position = "";
          pointerDrag.noteEl.style.zIndex = "";
          pointerDrag.noteEl.style.width = "";
          pointerDrag.noteEl.style.left = "";
          pointerDrag.noteEl.style.top = "";

          document.body.classList.remove("dragging-no-select");

          saveManualOrderFromContainer(pointerDrag.container);
          pointerDrag = null;

          renderAll();
          toast("Orden guardado");
        };

        window.addEventListener("pointermove", onMove, { passive: false });
        window.addEventListener("pointerup", onEnd, { passive: false });
        window.addEventListener("pointercancel", onEnd, { passive: false });
      }

      function autoScrollWindow(clientY) {
        const margin = 70;
        const speed = 14;

        if (clientY < margin) window.scrollBy({ top: -speed, left: 0, behavior: "auto" });
        else if (clientY > window.innerHeight - margin) window.scrollBy({ top: speed, left: 0, behavior: "auto" });
      }

    })();
  </script>
</body>
</html>