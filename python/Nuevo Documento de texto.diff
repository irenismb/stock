diff --git a/python/renombrar imagenes con codigos-catalogo.py b/python/renombrar imagenes con codigos-catalogo.py
index ee319d840697be8c8fc44f8ebdca3df6b2cc6537..3fd1b4ec3c4b6cf5d3b77de9f088e60838f9bd50 100644
--- a/python/renombrar imagenes con codigos-catalogo.py	
+++ b/python/renombrar imagenes con codigos-catalogo.py	
@@ -3034,55 +3034,72 @@ class ProductsUIMixin:
         product["code"] = new_code
         product["name"] = new_name
         product["search_text"] = normalize_text(f"{new_code} {new_name} {product.get('category','')} {product.get('brand','')} {product.get('unit_price','')} {product.get('stock','')}")
 
         # reconstruir índices + refrescar vista
         self.code_to_name = build_code_to_name_index(getattr(self, "products", []) or [])
         self.apply_search_filter()
 
     # ---- fin edición TreeView ----
 
 
 class RenameUIMixin:
 
     # =========================
     # NUEVO: Asignar códigos disponibles a imágenes sin código
     # =========================
     def _excel_numeric_code_stats(self):
         """
         Retorna (ok, err, excel_ints_set, min_int, max_int, width)
         width = longitud máxima encontrada en códigos numéricos (para zfill).
         """
         products = list(getattr(self, "products", []) or [])
         nums = []
         widths = []
         for p in products:
-            c = str(p.get("code", "") or "").strip()
-            if c.isdigit():
+            raw_code = str(p.get("code", "") or "").strip()
+            if not raw_code:
+                continue
+            if re.search(r"[A-Za-z]", raw_code):
+                continue
+            cleaned = raw_code.replace(" ", "").replace("\u00a0", "")
+            digits_only = "".join(ch for ch in cleaned if ch.isdigit())
+            if cleaned.isdigit():
+                try:
+                    nums.append(int(cleaned))
+                    widths.append(len(digits_only) if digits_only else len(cleaned))
+                except Exception:
+                    pass
+                continue
+            parsed = _parse_number_for_excel(cleaned)
+            if isinstance(parsed, (int, float)) and float(parsed).is_integer():
                 try:
-                    nums.append(int(c))
-                    widths.append(len(c))
+                    nums.append(int(parsed))
+                    if digits_only:
+                        widths.append(len(digits_only))
+                    else:
+                        widths.append(len(str(int(parsed))))
                 except Exception:
                     pass
 
         if not nums:
             return (False, "No encontré Id numéricos en el Excel para calcular huecos.", set(), 0, 0, 0)
 
         min_int = min(nums)
         max_int = max(nums)
         width = max(widths) if widths else len(str(max_int))
         return (True, "", set(nums), int(min_int), int(max_int), int(width))
 
     def _format_code_with_width(self, n: int, width: int) -> str:
         try:
             if width and width > 1:
                 return str(int(n)).zfill(int(width))
         except Exception:
             pass
         return str(int(n))
 
     def _iter_available_codes_in_range(self, min_int: int, max_int: int, occupied_ints: set, need: int):
         """
         Genera códigos disponibles (enteros) en [min_int, max_int] excluyendo occupied_ints,
         sin iterar todo el rango completo; se detiene al alcanzar 'need'.
         """
         if need <= 0:
